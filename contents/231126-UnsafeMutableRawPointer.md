# UnsafeMutableRawPointer 🤿

형식화되지 않은 데이터에 액세스하고 조작하기 위한 원시 포인터입니다.

```swift
@frozen
struct UnsafeMutableRawPointer
```

# 1️⃣ 개요.

**'UnsafeMutableRawPointer'** 타입은 자동 메모리 관리(ARC), 타입 안정성, 정렬 보장을 제공하지 않습니다.

당신은 안전하지 않은 포인터를 통해 작업하는 모든 메모리의 생명주기를 관리하는 책임이 있으며, 이를 통해 메모리 누수(memory leak)나 정의되지 않은 행동을 피해야 합니다.

수동으로 관리하는 메모리는 타입이 지정되지 않거나 특정 타입에 바인딩 될 수 있습니다.
**'UnsafeMutableRawPointer'** 타입은 메모리에 저장된 원시 바이트에 접근하고 관리하기 위해 사용되며, 해당 메모리가 특정 타입에 바인딩되었는지 여부와 상관없습니다.

> ✅ **정의되지 않은 행동(Undefined Behavior).**
> 
> **프로그래밍 언어의 명세에서 특정 조건이나 상황에 대해 어떠한 행동도 명확하게 정의하지 않은 상태를 말합니다.**
> 
> 이는 프로그래미이 예측 불가능한 방식으로 동작할 수 있음을 의미합니다.

> ✅ **정의되지 않은 행동의 주요 원인과 그 예시.**
> 
> **1. 메모리 접근 오류 :** 잘못된 메모리 주소에 접근하거나, 해제된 메모리를 다시 사용하는 경우와 같이 부적절한 메모리 접근이 발생할 때.
> **2. 타입 오용 :** 잘못된 타입으로 메모리를 해석하거나, 타입 안전을 위반하는 경우.
> **3. 정렬 위반 :** 데이터에 접근할 때 요구되는 메모리 정렬 규칙을 준수하지 않은 경우.

> 💯 **정의되지 않은 행동 마무리.**
> 
> 정의되지 않은 행동이 발생하면 프로그램이 충돌하거나 예상치 못한 결과를 생성할 수 있습니다.
> 더욱이, 이런 행동은 디버깅이 매우 어렵고, 때로는 보안 취약점으로 이어질 수 있습니다.
> 따라서, 프로그래머는 이러한 상황을 피하고 안전한 코드를 작성하기 위해 주의를 기울여야 합니다.
> **'UnsafeMutableRawPointer'** 와 같은 저수준 메모리 접근 방식을 사용할 때는 특히 이러한 위험을 인지하고 적절히 관리해야 합니다.

> ✅ **특정 타입에 바인딩.**
> 
> 이 표현은 메모리가 특정 데이터 타입으로 연결되거나 할당 될 수 있음을 의미합니다.
> 
> 이는 프로그래밍에서 메모리에 저장된 데이터가 어떤 타입의 값으로 해석될 수 있는지를 정의하는 것과 관련이 있습니다.
> 
> 예를 들어, 메모리에 정수, 부동 소수점, 문자열 또는 복잡한 구조체 등 다양한 타입의 데이터를 저장할 수 있습니다.
> 이때, 해당 메모리를 특정 타입에 "바인딩"한다는 것은 그 메모리가 그 타입의 인스턴스를 저장하고 있는 것으로 해석될 수 있음을 의미합니다.
> 
> **'UnsafeMutableRawPointer'** 와 같은 원시 포인터(raw pointer)의 경우, 기본적으로 메모리에 대한 타입 정보를 제공하지 않습니다.
> 
> 따라서, 개발자는 필요에 따라 메모리를 특정 타입에 바인딩하여 그 타입으로 메모리를 안전하게 접근하고 조작할 수 있습니다.
> 
> 이 과정은 타입 캐스팅(type casting)또는 메모리 해서(memory reinterpretation)과 관련이 있으며, 타입 안전성과 데이터 무결성을 유지하는 데 중요합니다.
> 
> 하지만 이러한 바인딩 과정은 매우 주의해서 수행해야 합니다.
> 
> 잘못된 타입으로 바인딩하면 데이터의 오용, 메모리 오류, 또는 정의되지 않은 행동을 초래할 수 있기 때문입니다.

# 2️⃣ Understanding a Pointer's Memory State(포인터의 메모리 상태 이해하기).

**"UnsafeMutableRawPointer"** 인스턴스가 참조하는 메모리는 여러 가지 상태 중 하나일 수 있습니다.
많은 포인터 연산은 특정 상태의 메모리를 가진 포인터에만 적용되어야 합니다.
따라서, 당신은 작업 중인 메모리의 상태를 추적하고, 다양한 연산이 그 상태에 어떤 변화를 주는지 이해해야 합니다.

메모리는 타입이 지정되지 않고 초기화되지 않은 상태일 수도 있고, 특정 타입에 바인딩되었지만 초기기화되지 않은 상태일 수도 있으며, 또는 특정 타입에 바인딩되고 값으로 초기화된 상태일 수도 있습니다.

마지막으로, 이전에 할당된 메모리가 해제되었을 수 있어, 기존 포인터들이 할당되지 않은 메모리를 참조하고 있을 수 있습니다.

> ✅ **메모리의 다양한 상태.**
> 
> **"UnsafeMutableRawPointer"** 가 가리키는 메모리는 여러 상태 중 하나일 수 있습니다.
> 이러한 상태는 메모리가 어떻게 할당되고 사용되는지에 따라 달라집니다.

> ✅ **상태에 따른 연산의 적용.**
> 
> 특정 포인터 연산들은 메모리가 특정 상태에 있을 때만 적용되어야 합니다.
> 개발자는 작업 중인 메모리 상태를 추적하고, 다양한 연산이 메모리 상태에 어떤 변화를 일으키는지 이해해야 합니다.

> ✅ **메모리의 상태 유형.**
> 
> - **Untyped and Uninitialized(타입이 지정되지 않고 초기화되지 않은 상태) :** 메모리가 할당되었지만 아직 어떤 특징 타입의 데이터로 초기화되지 않은 상태입니다.
> 
> - **Bound to a Type and Uninitialized(특정 타입에 바인딩되었지만 초기화되지 않은 상태) :** 메모리가 특정 타입에 바인딩되었지만, 해당 타입의 값을 아직 가지고 있지 않은 상태입니다.
> 
> - **Bound to a Type and Initialized(특정 타입에 바인딩되고 초기화된 상태) :** 메모리가 특정 타입으로 바인딩되고, 해당 타입의 값으로 초기화된 상태입니다.

> ✅ **할당 해제된 메모리.**
> 
> 이전에 할당된 메모리가 해제되었을 수 있으며, 이 경우 기존 포인터는 할당되지 않은 메모리를 가리키고 있을 수 있습니다.
> 
> 이는 포인터가 무효화되었음을 의미하며, 이런 상태의 메모리에 접근하는 것은 위험합니다.

> 💯 **Understanding a Pointer's Memory State 요약**
> 
> 개발자가 **'UnsafeMutableRawPointer'** 를 사용할 때 메모리 상태를 정확히 이해하고, 적절한 연산을 적용하며, 잠재적인 위험을 피하기 위해 필요한 주의를 기울여야 합니다.
> 
> 메모리의 상태를 정확히 파악하고 관리하는 것은 안전하고 효율적인 저수준 메모리 조작을 위해 필수적입니다.

> ✅ **포인터(Pointer)**
> 
> 프로그래밍에서 **"포인터(Pointer)"** 는 메모리의 주소를 저장하는 변수입니다.
> 
> 즉, 포인터는 메모리 상의 특정 위치를 가리키며, 이를 통해 해당 위치에 저장된 데이터에 접근할 수 있습니다.

> ✅ **포인터(Pointer)의 주요 특징과 사용 목적.**
> 
> **1. 메모리 주소 저장 :** 포인터는 메모리 주소를 저장합니다. 이 주소는 메모리 내의 특정 위치를 나타냅니다.
> 
> **2. 간접적인 데이터 접근 :** 포인터를 통해 메모리에 간접적으로 접근할 수 있습니다. 즉, 포인터를 사용하여 메모리의 특정 위치에 저장된 값을 읽거나 수정할 수 있습니다.
> 
> **3. 동적 메모리 관리 :** 포인터는 동적 메모리 할당에 중요한 역할을 합니다. 프로그램 실행 중에 필요한 메모리를 동적으로 할당하고, 이 메모리를 포인터를 통해 관리할 수 있습니다.
> 
> **4. 복잡한 데이터 구조 :** 포인터는 배열, 연결 리스트, 트리, 그래프 등과 같은 복잡한 데이터 구조를 구현하는 데 필수적입니다.
> 
> **5. 효율적인 함수 인자 전달 :** 포인터를 사용하여 함수에 데이터를 효율적으로 전달할 수 있습니다. 특히, 큰 데이터 구조를 함수에 전달할 때 포인터를 사용하면 메모리 복사를 줄일 수 있어 성능상의 이점이 있습니다.
> 
> **6. 저수준 프로그래밍 :** 포인터는 메모리에 직접 접근할 수 있게 해주므로, 하드웨어나 운영 체제와 같은 저수준 프로그래밍에 매우 유용합니다.

> 💯 **포인터 요약**
> 
> Swift와 같은 현대 언어에서는 포인터를 직접 다루는 것이 일반적으로 제한되어 있으며, 대신 안전한 메모리 관리 방법을 사용합니다.
> 
> 그러나 특정 상황에서는 **'UnsafeMutableRawPointer'** 와 같은 저수준 포인터를 사용하여 메모리에 직접 접근할 필요가 있을 수 있습니다.
> 
> 이러한 경우, 포인터를 사용할 때 메모리 관리와 안전성에 특별한 주의를 기울여야 합니다.

# 3️⃣ Raw, Uninitialized Memory

방금 할당된 원시 메모리는 초기화되지 않은, 타입이 지정되지 않은 상태입니다.(Raw Memory in an Uninitialized, Untyped State)
초기화되지 않은 메모리는 어떠한 타입의 연산에 사용되기 전에 반드시 특정 타입의 값으로 초기화되어야 합니다.

**`initializeMemory(as:from:)`** 및 **`moveInitializeMemory(as:from:count:)`** 같은 메소드를 사용하여 원시 메모리를 특정 타입에 바인딩하고 하나 이상의 값으로 초기화할 수 있습니다.
초기화하지 않고 원시 메모리를 특정 타입에 바인딩하려면 `bindMemory(to:count:)` 메소드를 사용합니다.
이러한 메소드들은 메모리에 대한 추가적인 타입-특화된 접근을 위해 타입화된 포인터를 반환합니다.

> **✅ "타입화된 포인터를 반환합니다."라는 구문의 의미.**
> 
> **1. 타입화된 포인터(Typed Pointer).**
> 
> **타입화된 포인터란 특정 데이터 타입에 대한 메모리 주소를 가리키는 포인터 입니다.**
> 예를 들어, Int, String 또는 다른 사용자 정의 타입과 같은 특정 타입의 데이터를 참조합니다.
> 이는 포인터가 가리키는 메모리 영역이 어떤 타입의 데이터로 구성되어 있는지를 명시합니다.
> 
> **2. 메모리 바인딩 후의 반환 값.**
> 
> `bindMemory(to:count:)` 메소드를 사용하여 원시 메모리를 특정 타입에 바인딩하면, 이 메소드는 해당 타입을 다룰 수 있는 포인터를 반환합니다.
> 예를 들어, 메모리를 Int 타입에 바인딩하면 Int 타입의 데이터를 참조할 수 있는 포인터가 반환됩니다.
> 
> **3. 타입-특화된 접근.**
> 
> 이 타입화된 포인터를 사용하면, 프로그래머는 해당 메모리 영역을 안전하고 정확하게 해당 타입의 데이터를 다룰 수 있습니다.
> 이는 메모리의 안전한 사용을 보장하고, 타입 불일치로 인한 오류를 방지하는 데 도움이 됩니다.
> 
> **💯 "타입화된 포인터를 반환합니다."라는 구문의 의미 요약.**
> 
> 요약하면, "타입화된 포인터를 반환합니다"는 메모리를 특정 타입에 바인딩한 후, 해당 타입의 데이터를 안전하게 접근하고 조작할 수 있도록 하는 포인터를 제공한다는 의미입니다.
> 
> 이는 메모리를 직접 다루는 저수준 프로그래밍에서 매우 중요한 개념입니다.

# 4️⃣ Typed Memory

타입에 바인딩된 메모리는 초기화되었든 초기화되지 않았든, 일반적으로 타입화된 포인터 - **`UnsafePointer`** 와 **`UnsafeMutablePointer`** 의 인스턴스를 사용하여 접근됩니다.
초기화, 할당, 그리고 해제는 **`UnsafeMutablePointer`** 메소드를 사용하여 수행될 수 있습니다.

타입에 바인딩된 메모리는 해제되었거나 바인딩된 타입이 단순한(trivial) 타입인 경우에만 다른 타입으로 다시 바인딩될 수 있습니다.
타입화된 메모리를 해제하는 것은 그 메모리의 타입 바인딩을 해제하지 않습니다.
해제된 메모리는 같은 타입의 값으로 다시 초기화 되거나, 새로운 타입에 바인딩되거나, 메모리 해제(deallocate)될 수 있습니다.

> 📝 **참고**
> 
> 단순한(trivial) 타입은 간접 접근이나 참조 카운팅 연산 없이 비트 단위로 복사될 수 있습니다.
> 일반적으로, 강한(strong) 또는 약한(weak) 참조나 기타 형태의 간접 접근을 포함하지 않는 네이티브 Swift 타입들은 단순한 타입입니다.
> 또한, C 언어로부터 가져온 구조체(structs)와 열거형(enumerations)도 단순한 타입에 해당합니다.

타입에 바인딩된 메모리를 원시 바이트로 읽거나 쓸 때는, 어떠한 정렬 요구사항도 충족시켜야 합니다.
타입화된 메모리를 원시바이트로 쓰는 것은 바인딩된 타입이 단순한 타입일 때만 수행되어야 합니다.

> **✅ "단순한(trivial) 타입"의 의미.**
> 
> **"단순한(trivial) 타입"** 이라는 표현은 프로그래밍, 특히 Swift 언어에서 사용되는 개념으로, 메모리 관리와 관련된 특정 유형의 데이터 타입을 지칭합니다.
> 
> 여기서 **"단순한(trivial)"** 타입의 의미는 다음과 같습니다.
> 
> **1, 간단한 메모리 관리.**
> 
> 단순한 타입은 복잡한 메모리 관리나 라이프사이클 관리가 필요하지 않은 타입을 의미합니다.
> 이러한 타입은 메모리를 할당하거나 해제할 때 추가적인 처리가 필요 없습니다.
> 
> **2. 복사와 할당의 간단함.**
> 
> 단순한 타입의 객체는 보통 복사가 간단하며, 깊은 복사(deep copy)나 참조 카운팅(reference counting)과 같은 복잡한 메커니즘이 필요하지 않습니다.
> 
> 예를 들어, 기본 데이터 타입(primitive data types)인 정수(integers), 실수(floating-point numbers), 문자(character) 등이 이에 속합니다.
> 
> **3. 커스텀 초기화나 해제 불필요.**
> 
> 단순한 타입은 특별한 초기화나 해제 절차가 필요하지 않습니다. 즉, 사용자 정의 생성자나 소멸자가 필요 없으며, 메모리에서 직접 할당하거나 해제할 수 있습니다.


> **✅ "타입화된 메모리를 해제하는 것은 그 메모리의 타입 바인딩을 해제하지 않습니다." 구문의 의미.**
> 
> **1. 타입화된 메모리 Deinitialization.**
> 
> 타입화된 메모리를 '해제(deinitialize)'한다는 것은 해당 메모리에 저장된 데이터를 안전하게 제거하거나 초기화 상태로 되돌린다는 의미입니다.
> 예를 들어, 객체의 메모리를 해제하면 그 객체의 모든 프로퍼티와 자원이 정리되며, 메모리는 다시 사용할 수 있게됩니다.
> 
> **2. 타입 바인딩 유지.**
> 
> 그러나 이 과정에서 중요한 점은 메모리가 해제되어도, 해당 메모리 영역이 원래 바인딩되었던 특정 타입과의 연결(바인딩)은 해제되지 않는다는 것입니다.
> 즉, 메모리 영역은 여전히 처음 바인딩된 타입으로 간주됩니다.
> 
> **3. 재사용과 재바인딩의 제한.**
> 
> 이는 해당 메모리 영역을 다른 타입의 데이터로 재사용하려면 추가적인 단계가 필요함을 의미합니다.
> 즉, 다른 타입의 데이터를 저장하기 전에, 해당 메모리 영역을 명시적으로 새로운 타입에 바인딩해야 합니다.
> 
> **💯 "타입화된 메모리를 해제하는 것은 그 메모리의 타입 바인딩을 해제하지 않습니다." 구문의 의미 요약.**
> 
> 요약하면, 이 구문은 메모리의 데이터를 해제해도 메모리가 처음 바인딩된 타입에 계속 연결되어 있음을 나타냅니다.
> 이러한 이해는 메모리를 안전하게 관리하고, 타입 불일치로 인한 오류를 방지하는 데 중요합니다.

> **✅ 원시 바이트(raw bytes)**
> 
> **원시 바이트(raw bytes)** 는 컴퓨터 메모리에 저장된 데이터를 가장 기본적인 형태, 즉 바이트 단위로 표현한 것을 의미합니다.
> 이 용어는 프로그래밍 및 컴퓨터 과학에서 다음과 같은 특징을 갖는 데이터를 지칭합니다.
> 
> **1. 기본 바이트** 
> 바이트는 컴퓨터 메모리의 기본 단위로, 대부분의 컴퓨터 시스템에서는 8비트(8bit)로 구성됩니다.
> 원시 바이트는 이러한 바이트 단위의 데이터를 가리킵니다.
> 
> **2. 타입 미지정.**
> 원시 바이트는 특정한 데이터 타입(예: 정수, 실수, 문자열 등)에 구속되지 않은 원형(raw) 데이터 상태를 나타냅니다.
> 이는 메모리에 저장된 데이터를 타입 없이 단순히 바이트의 연속으로만 간주한다는 의미입니다.
> 
> **3. 저수준 접근.**
> 원시 바이트로의 접근은 보통 저수준 프로그래밍에서 이루어집니다.
> 이는 데이터를 타입화된 형태로 해석하기 전의 단계로, 메모리의 실제 내용을 직접 조작할 수 있게 해줍니다.
> 
> **4. 다양한 해석 가능성.**
> 원시 바이트는 상황에 따라 다르게 해석될 수 있습니다.
> 예를 들어, 동일한 바이트 시퀀스가 한 상황에서는 정수로, 다른 상황에서는 문자열이나 다른 데이터 타입으로 해석될 수 있습니다.
> 
> **💯 원시 바이트(raw bytes) 마무리.**
> 
> 원시 바이트는 메모리와 데이터를 다루는 가장 기본적이고 유연한 방법 중 하나이지만, 정확한 해석과 안전한 사용을 위해서는 주의가 필요합니다.
> 잘못된 해석이나 사용은 데이터 손상이나 시스템 오류를 일으킬 수 있습니다.

> **✅ 정렬 규칙(alignment rules)**
> 
> **정렬 규칙(alignment rules)** 은 컴퓨터 메모리에서 데이터를 저장하거나 접근할 때 적용되는 규칙입니다.
> 
> 이 규칙들은 데이터가 메모리 상에서 어떻게 위치해야 하는지를 정의하며, 효율적이고 안전한 메모리 접근을 위해 중요합니다.
> 
> 정렬 규칙의 주요 개념은 다음과 같습니다.
> 
> **1. 메모리 정렬(Memory Alignment).**
> 메모리 정렬은 데이터가 메모리 주소의 특정 배수에 맞춰서 저장되어야 한다는 원칙입니다.
> 예를 들어, 4바이트 정렬의 경우 데이터는 4의 배수인 메모리 주소에 저장되어야 합니다.
> 
> **2. 성능 최적화.**
> 정렬된 메모리 접근은 컴퓨터의 메모리와 버스 아키텍처에 따라 성능을 최적화합니다.
> 일반적으로, 정렬된 데이터는 비정렬된 데이터에 비해 빠르게 접근하고 처리할 수 있습니다.
> 
> **3. 플랫폼 및 언어 요구사항.**
> 다양한 컴퓨터 시스템과 프로그래밍 언어는 서로 다른 정렬 요구사항을 가질 수 있습니다.
> 일부 시스템은 엄격한 정렬을 요구하는 반면, 다른 시스템은 덜 엄격할 수 있습니다.
> 
> **4. 오류 방지.**
> 정렬을 따르지 않는 메모리 접근은 오류를 발생시킬 수 있습니다.
> 특히, 일부 하드웨어는 비정렬 메모리 접근에 대해 예외를 발생시키거나 비효율적인 처리를 수행할 수 있습니다.
> 
> **5. 데이터 타입에 따른 차이.**
> 다른 데이터 타입은 다른 정렬 요구사항을 가질 수 있습니다.
> 예를 들어, 정수, 부동소수점, 구조체 등 각각의 타입은 메모리 상에서 다르게 정렬될 수 있습니다.
> 
> **💯 정렬 규칙(alignment rules) 마무리.**
> 
> 정렬 규칙은 메모리의 효율적인 사용과 시스템의 안정성을 유지하기 위해 필수적인 요소이며, 프로그래머는 이를 고려하여 메모리를 안전하게 사용해야 합니다.

# 5️⃣ Raw Pointer Arithmetic

**원시 포인터(Raw Pointer)로 수행되는 포인터 연산은 바이트 수준에서 이루어집니다.**
원시 포인터에 더하거나 빼는 것은 그 수만큰 바이트로 오프셋된 새로운 원시 포인터의 결과를 만듭니다.
다음 예제에서는 네 바이트의 메모리를 할당하고 모든 네 바이트에 0xFF를 저장합니다.

```swift
let bytesPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 1)
bytesPointer.storeBytes(of: 0xFFFF_FF, as: UInt32.self)

// 'bytesPointer'가 참조하는 메모리에서 값을 로드합니다.
let x = bytesPointer.load(as: UInt.self) // 255

// 할당된 마지막 두 바이트에서 값을 로드합니다.
let offsetPointer = bytesPointer + 2
let y = offsetPointer.load(as: UInt16.self) // 65535
```

위 코드는 새롭게 할당된 네 바이트에 0xFFFF_FFFF 값을 저장하고, 첫 번째 바이트를 UInt8 인스턴스로, 세 번째와 네 번째 바이트를 UInt16 인스턴스로 로드합니다.

자신이 할당한 메모리는 반드시 해제하는 것을 잊지 마세요.

```swift
bytesPointer.deallocate()
```

> ✅ 코드 해석 1️⃣
> 
> ```swift
> let offsetPointer = bytesPointer + 2
> ```
> 
> 위 코드 스니펫은 **원시 포인터(`'bytePointer')`** 를 사용하여 특정 바이트 오프셋으로 새로운 포인터를 생성하는 것을 나타냅니다.
> 
> 여기서의 의미와 작동 원리는 다음과 같습니다.
> 
> **1. 원시 포인터('`bytePointer`') :** **`'bytePointer'`** 는 4바이트의 메모리를 할당받은 원시 포인터입니다. 이 포인터는 할당된 메모리 블록의 시작 주소를 가리킵니다.
> 
> **2. 오프셋 추가 :** **`'bytePointer + 2'`** 연산은 **`'bytePointer'`** 가 가리키는 주소에서 2바이트 뒤의 주소를 가리키는 새로운 포인터(**`'offsetPointer'`**)를 생성합니다.
> 이는 **`'bytesPointer'`** 의 시작 주소로부터 2바이트 뒤의 위치를 참조하게 됩니다.
> 
> **3. 새로운 포인터(`'offsetPointer'`) :** 생성된 새 포인터 **`'offsetPointer'`** 는 **`'bytesPointer'`** 가 가리키는 메모리 블록 내에서 2바이트 뒤의 위치를 가리킵니다. 이 포인터는 원래 메모리 블록의 처음부터가 아닌, 중간부터 시작하는 위치를 참조합니다.
> 
> **4. 이후의 메모리 접근 :** 이 새로운 포인터는 이후에 **`'load(as:)'`** 메소드를 통해 특정 타입(**`'UInt16.self'`**)으로 해당 위치의 메모리 내용을 읽는 데 사용됩니다.
> 
> 이러한 방식으로 포인터와 오프셋 연산을 사용하면, 메모리 블록 내의 특정 위치에 접근하고 해당 위치의 데이터를 읽거나 수정할 수 있습니다.
> 이는 메모리 조작과 관련된 저수준 프로그래밍에서 자주 사용되는 기법입니다.

> ✅ **"원시 포인터로 수행되는 포인터 연산 방식은 비이트 수준에서 이루어집니다." 의 의미.**
> 
> **1. 점밀한 메모리 제어.**
> 이러한 연산 방식은 프로그래머가 메모리의 특정 부분에 정밀하게 접근하고 조작할 수 있도록 해줍니다.
> 예를 들어, 배열의 특정 요소에 접근하거나, 메모리 블록 내에서 데이터를 이동 시키는 등의 작업을 수행할 때 유용합니다.
> 
> **💯 "원시 포인터로 수행되는 포인터 연산 방식은 비이트 수준에서 이루어집니다." 요약.**
> 
> 요약하면, 이 문장은 원시 포인터를 사용하여 메모리 내에서 바이트 단위의 정밀한 연산이 가능함을 나타냅니다.
> 이는 메모리를 저수준으로 다룰 때 중요한 개념이며, 메모리의 특정 영역을 효과적으로 조작할 수 있게 해줍니다.

> ✅ **"바이트 수준 연산"의 의미.**
> 
> 바이트 수준에서의 연산은 원시 포인터가 가리키는 메모리 주소를 바이트 단위로 계산한다는 것을 의미합니다.
> 예를 들어, 포인터에 정수를 더하거나 빼면, 그 정수 값인 바이트 단위로 해석되어 포인터의 주소가 이동합니다.

> ✅ **"원시 포인터에 더하거나 빼는 것은 그 수만큼 바이트로 오프셋된 새로운 원시 포인터의 결과를 만듭니다" 문장의 의미.**
> 
> **1. 포인터 연산.**
> 프로그래밍에서 포인터 연산은 주로 주소를 가리키는 포인터에 정수 값을 더하거나 빼는 것을 말합니다.
> 이 연산은 포인터가 가리키는 주소를 변경합니다.
> 
> **2. 바이트 수준의 오프셋.**
> 원시 포인터(raw pointer)는 메모리의 특정 위치를 가리키는 주소입니다.
> 이 포인터에 정수를 더하거나 빼면, 연산 결과는 원래 포인터 주소에서 해당 정수만큼 바이트로 오프셋(offset, 즉 이동)된 새로운 주소를 가리키는 포인터가 됩니다.
> 
> **3. 새로운 원시 포인터 생성.**
> 예를 들어, 어떤 원시 포인터가 메모리의 100번지를 가리키고 있고, 여기에 3을 더하면, 새로운 포인터는 100번지에서 3바이트 뒤인 103번지를 가리키게 됩니다.
> 반대로 2를 빼면 98번지를 가리키게 됩니다.
> 
> **💯 마무리.**
> 
> 이러한 포인터 연산은 메모리의 다른 부분으로 포인터를 이동시키거나, 배열과 같은 데이터 구조를 순회할 때 유용하게 사용됩니다.
> 하지만 잘못된 연산은 잘못된 메모리 영역에 접근할 수 있기 때문에 주의를 기울여야 합니다.

> 📝 참고.
> 
> **"오프셋(offset)"** 이라는 용어는 프로그래밍 및 컴퓨터 과학에서 '이동' 또는 '위치의 차이'를 의미합니다.

# 6️⃣ Implicit Casting and Bridging

**"UnsafeMutableRawPointer"** 매개변수를 가진 함수나 메소드를 호출할 때, 해당 특정 포인터 타입의 인스턴스를 전달하거나, 호환되는 포인터 타입의 인스턴스를 전달하거나, 또는 Swift의 암시적 브리징(implicit bridging)을 사용하여 호환되는 포인터를 전달할 수 있습니다.

예를 들어, 다음 코드 샘플의 `print(address:as:)` 함수는 첫 번째 매개변수로 **`UnsafeMutableRawPointer`** 인스턴스를 받습니다.

```swift
func print<T>(address p: UnsafeMutableRawPointer, as type: T.Type) {
    let value = p.load(as: type)
    print(value)
}
```

Swift에서 일반적으로, `print(address:as:)` 함수를 `UnsafeMutableRawPointer` 인스턴스로 호출할 수 있습니다.

이 예제에서는 초기 매개변수로 `rawPointer`를 전달합니다.

```swift
// 'rawPointer'는 'Int' 값으로 초기화된 메모리를 가리킵니다.
let rawPointer: UnsafeMutableRawPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 1)
rawPointer.storeBytes(of: 42, as: Int.self)
print(address: rawPointer, as: Int.self)
// "42"를 출력합니다.
```

> 🧑‍💻 **코드 해석.**
> 
> **1. 메모리 할당.**
> 
> **`'UnsafeMutableRawPointer.allocate'`** 를 사용하여 4바이트의 메모리를 할당합니다.
> 여기서 **`'alignment: 1'`** 은 메모리가 1바이트 경계에 정렬되어야 함을 나타냅니다.
> 
> **2. 값의 저장.**
> 
> **`'storeBytes(of:as:)'`** 메소드를 통해 할당되 메모리에 **`'42'`** 라는 **`'Int'`** 타입의 값을 저장합니다.

> ✅ **"메모리가 1바이트 경계에 정렬되어야 함을 나타냅니다"에서 "경계"의 의미.**
> 
> 컴퓨터 과학 및 프로그래밍에서 **"경계"** 라는 용어는 주로 **"메모리 정렬(memory alignment)"** 과 관련하여 사용됩니다.
> 이 맥락에서 경계는 메모리 주소가 충족해야 하는 특정한 조건이나 규칙을 의미합니다.
> 경계의 의미를 좀 더 자세히 설명하면 다음과 같습니다.
> 
> **1. 메모리 주소의 배수 조건.**
> 
> 메모리 경계는 주로 메모리 주소가 특정 숫자의 배수여야 한다는 조건을 나타냅니다.
> 예를 들어, 4바이트 경계 정렬은 메모리 주소가 4의 배수여야 함을 의미합니다.
> 이는 해당 주소가 4, 8, 12, 16 등으로 끝나야 한다는 것을 의미합니다.
> 
> **2. 데이터 처리 효율성.**
> 
> 특정 데이터 타입은 특정 바이트 경계에 정렬될 때 처리 속도와 효율성이 향상될 수 있습니다.
> 예를 들어, 몇몇 CPU는 특정 타입의 데이터를 처리할 때, 그 데이터가 특정 바이트 경계에 정렬되어 있지 않으면 성능이 저하될 수 있습니다.
> 
> **3. 하드웨어와 시스템 요구사항.**
> 
> 다양한 컴퓨터 시스템과 하드웨어는 메모리에 데이터를 저장하거나 접근할 때 서로 다른 정렬 요구사항을 가질 수 있습니다.
> 이러한 요구사항은 해당 시스템의 하드웨어 아키텍처와 밀접한 관련이 있습니다.
> 
> **💯 "경계"의 의미 마무리.**
> 
> 경계 정렬은 메모리의 효율적 사용, 시스템의 성능 최적화 및 안정성 유지를 위한 중요한 요소입니다.
> 따라서 프로그래머들은 메모리를 할당하고 접근할 때 이러한 경계 조건을 고려하여야 합니다.

매개변수로 전달 될 때 타입화된 포인터가 원시 포인터로 암시적으로 캐스팅될 수 있으므로 **`'print(address:as):'`** 를 어떤 가변 타입 포인터 인스턴스로도 호출할 수 있습니다.

```swift
let intPointer: UnsafeMutablePointer<Int> = ...
print(address: intPointer, as: Int.self)
// "42"를 출력합니다.
```

> ✅ **"암시적 캐스팅의 의미"**
> 
> "매개변수로 전달될 때 타입화된 포인터가 원시 포인터로 암시적으로 캐스팅될수 있다"는 말은, 타입화된 포인터(**`'UnsafeMutablePointer<Int>'`** 등)가 함수나 메소드를 호출할 때 원시 포인터 (**`'UnsafeMutableRawPointer'`**)로 자동으로 변환될 수 있음을 의미합니다. **이는 Swift가 타입 정보를 유지하면서도, 더 일반적인 원시 포인터 형태로의 변환을 자동으로 처리해준다는 것을 나타냅니다.**

> ✅ **"가변 타입 포인터의 사용"**
> 
> 예제 코드에서 **`let intPointer: UnsafeMutablePointer<Int> = ...`** 는 **`Int`** 타입을 가리키는 가변(mutable) 포인터를 선언하고 초기화합니다.
> 이 포인터는 **`Int`** 타입의 데이터를 가리키며, 메모리의 해당 부분을 읽거나 쓸 수 있습니다.

> ✅ **"함수 호출과 출력"**
> 
> **`'print(address: intPointer, as: Int.self)'`** 코드에는 **`'intPointer'`** 를 **`'print(address:as:)'`** 함수에 매개변수로 전달합니다. 이 때, **`'intPointer'`** 는 **`'UnsafeMutablePointer<Int>'`** 타입이지만, 함수 내에서는 **`'UnsafeMutableRawPointer'`** 로 처리됩니다.
> 만약 **`'intPointer'`** 가 메모리에서 **`'42'`** 라는 **`'Int'`** 타입의 값을 가리키고 있다면 , 이 값이 출력됩니다.

> 🤔 **의문점 1️⃣**
> 
> "`let intPointer: UnsafeMutablePointer<Int> = ...`는 `Int` 타입을 가리키는 **가변(mutable) 포인터** 를 선언하고 초기화합니다. 이 포인터는 `Int` 타입의 데이터를 가리키며, 메모리의 해당 부분을 읽거나 쓸 수 있습니다." 이 문장에서 `let intPointer: UnsafeMutablePointer<Int> = ...` 이 코드는 `"let"`인데 왜 **가변**인가요?
> 
> 🙋‍♂️ **답변 1️⃣**
> 
> Swift에서 **`let`** 키워드는 **변수가 참조하는 객체 또는 값** 자체가 **불변(immutable)** 임을 의미하는 것이 아니라, **해당 변수가 참조하는 대상의 주소나 참조 자체가 변경되지 않음을 의미합니다.**
> 
> **즉, 변수가 한 번 초기화된 후에는 다른 객체나 값을 참조하도록 변경될 수 없습니다.**
> 
> 그러나 **`'let'`** 으로 선언된 **포인터**가 가리키는 **메모리 내용**은 **가변**일 수 있습니다.
> 
> **`let intPointer: UnsafeMutablePointer<Int> = ...`** 에서 **`intPointer`** 는 **`UnsafeMutablePointer<Int>`** 타입으로 선언되었습니다:
> 
> - **`UnsafeMutablePointer<Int>` :** 이 타입은 **`Int`** 타입의 데이터를 가리키는 **가변(mutable)** 포인터입니다. **"가변"** 이라는 용어는 포인터가 가리키는 메모리 위치에 저장된 데이터가 변경될 수 있음을 의미합니다.
> 
> - **`let`** 키워드 사용: 여기서 **`let`** 키워드는 **`intPointer`** 변수 자체가 다른 주소를 가리키도록 변경되지 않을 것임을 나타냅니다. 즉, **`intPointer`** 는 초기화된 후에 다른 **`UnsafeMutablePointer<Int>`** 인스턴스나 다른 주소를 가리키도록 변경될 수 없습니다.
> 
> 💯 **결론 1️⃣**
> 
> 결론적으로, **`let intPointer`** 는 포인터 자체의 불변성을 의미하지만,**포인터가 가리키는 메모리의 내용**(여기에서는 **`Int`** 타입의 데이터)은 **가변적**으로 변경될 수 있습니다.
> 이는 포인터가 가리키는 메모리 주소는 고정되어 있지만, **그 메모리 주소에 저장된 값은 변경될 수 있음을 의미합니다.**

또한, Swift의 암시적 브리징을 사용하여 인스턴스나 배열의 요소에 대한 포인터를 전달할 수 있습니다.
inout 문법을 사용하여 어떤 타입의 인스턴스에 대한 포인터를 암시적으로 생성할 수 있습니다.
다음 예제에서는 `print(address:as:)` 를 호출할 때 `value`에 대한 포인터를 함시적으로 전달하는 데 사용됩니다.

```swift
var value: Int = 23
print(address: &value, as: Int.self)
// "23"을 출력합니다.
```

배열을 inout 문법을 사용하여 전달하면 배열의 요소에 대한 가변 포인터가 암시적으로 생성됩니다.
이 예제에서는 `print(address:as:)`를 호출할 때 `numbers`의 요소에 대한 포인터를 암시적으로 전달하는 데 사용됩니다.

```swift
var numbers = [5, 10, 15, 20]
print(address: &numbers, as: Int.self)
// "5"를 출력합니다.
```

> 🤔 **의문점 2️⃣**
> 
> 위 예시 코드에서는 어떻게 **"5"** 를 출력할까?

> 🙋‍♂️ **답변 2️⃣**
> 
> 제공된 코드에서 **`numbers`** 배열의 첫 번째 요소(5)의 주소를 **`print(address:as:)`** 함수에 전달하고 있습니다.
> 
> 이 함수는 전달된 주소에 저장된 값을 **`Int.self`** 타입으로 읽어서 출력합니다.
> 
> **코드 해석은 다음과 같습니다.**
> 
> **1. 배열 선언 :** **`var numbers = [5, 10, 15, 20]`** 은 **`Int`** 타입의 요소를 가지는 배열을 선언하고 초기화 합니다.
> 이 배열에는 순서대로 5, 10, 15, 20 이라는 네 개의 정수가 저장됩니다.
> 
> **2. 배열의 첫 번째 요소 주소 :** **`&numbers`** 는 **`numbers`** 배열의 메모리 주소를 나타냅니다.
> 배열은 연속된 메모리 블록에 데이터를 저장하기 때문에, 이 주소는 배열의 첫 번째 요소(여기서는 5)를 가리킵니다.
> 
> **3. 값의 로드 및 출력 :** **`print(address: &numbers, as: Int.self)`** 는 **`&numbers`** 가 가리키는 주소에서 **`Int`** 타입의 데이터를 읽어서 출력합니다.
> 따라서, 배열의 첫 번째 요소인 5가 출력됩니다.
> 
> 💯 **의문점 2️⃣ 마무리.**
> 
> 결과적으로, 이 코드는 배열 **`numbers`** 의 첫 번째 요소인 5를 출력하게 됩니다.
> 배열의 나머지 요소(10, 15, 20)는 이 코드에서 접근하거나 출력되지 않습니다.

## 🙌 중요!

인스턴스나 배열의 요소들에 대한 암시적 브리징을 통해 생성된 포인터는 호출된 함수의 실행 동안에만 유효합니다.
함수 실행 후에 포인터를 벗어나 사용하는 것은 정의되지 않은 행동입니다.
특히, **`UnsafeMutableRawPointer`** 초기화자를 호출할 때 암시적 브리징을 사용하지 마세요.

> ✅ **암시적 브리징으로 생성된 포인터의 유효성.**
> 
> Swift에서는 인스턴스나 배열의 요소에 대한 포인터를 암시적으로 생성할 수 있습니다.
> 이 방법을 사용하면, 함수 내에서 인스턴스나 배열의 메모리 주소에 접근할 수 있는 포인터를 얻을 수 있습니다.
> 그러나 이러한 포인터는 해당 함수가 실행되는 동안에만 유효합니다.

> ✅ **함수 실행 외부에서의 포인터 사용 금지.**
> 
> 함수 실행이 끝난 후에 이 포인터를 사용하는 것은 정의되지 않은 행동(Undefined behavior)을 초래할 수 있습니다.
> 즉, 함수 외부에서 이 포인터를 사용하면 안전하지 않으며, 예측할 수 없는 결과나 오류가 발생할 수 있습니다.

> ✅ **`UnsafeMutableRawPointer` 초기화자와의 관련성** 
> 
> 특히, **`UnsafeMutableRawPointer`** 초기화자를 호출할 때는 이러한 암시적 브리징을 사용해서는 안 됩니다.
> **`UnsafeMutableRawPointer`** 는 메모리에 대한 저수준 접근을 제공하므로, 이를 안전하게 사용하기 위해서는 명시적인 메모리 관리가 필요합니다.

---

### 참고 자료 📚

- [0과 1로 숫자를 표현하는 방법.](https://github.com/devKobe24/CS/blob/main/Kobe/231112.md)
- [메모리의 주소 공간](https://github.com/devKobe24/CS/blob/main/Kobe/231126.md)
- [Apple Developer Docs - UnsafeMutableRawPointer](https://developer.apple.com/documentation/swift/unsafemutablerawpointer)
