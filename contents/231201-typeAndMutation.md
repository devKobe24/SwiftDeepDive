# Type & Mutarion  🤿

"**타입(Type)**"이란 데이터의 논리적 그룹과 그 데이터를 가지고 수행할 수 있는 일련의 연산들을 말합니다.

Swift 프로그래밍에서는 표준타입(Standard Types)과 사용자 정의 타입(Custom Types)을 사용하여 프로그램을 구축합니다.

Swift 컴파일러는 종종 타입 정보를 사용하여 프로그램이 실행되기 전에 **타입 체킹(Type checking)** 이라는 과정을 통해 정확성을 보장할 수 있습니다.

처음에 **'옵셔널(optional)'** 과 낯선 타입을 다루는 초보자들은 타입 체킹 오류를 다소 번거롭고 알 수 없는 것으로 여길 수 있습니다.

하지만 **타입 시스템** 을 통한 프로그램의 타입 체킹은 소프트웨어를 올바르게 사용하도록 보장하며 많은 최적화를 가능하게 합니다.

**Swift의 타입 시스템**은 안전하고 효율적인 코드의 핵심입니다.
보다 고급 개발자가 되면서, 프로그래밍 관점은 더욱 타입 중심적이 될 것입니다.

Swift는 타입에 대해 **가변 값 의미론(Mutable value semantics)** 을 강조합니다.
이 글에서는 Swift가 제공하는 중요한 **명명 타입(Nominal types)** 을 검토할 것입니다.

값 타입(Value types; 열거형과 구조체), 참조 타입(Reference types; 클래스) 및 변이 규칙(Mutation rules)은 모두 가변 값 의미론을 가능하게 하며, 이를 자신 Swift 타입에 적용할 수 있습니다.

# 1️⃣ The fundamental types

Swift 타입 시스템은 몇 가지 기본 타입으로 구성되어 있습니다.
이러한 타입에는 소위 명명된 타입(프로토콜, 열거형, 구조체 및 클래스)과 복합 타입(함수와 튜플)이 포함됩니다.
이들 각각의 타입은 특정 상황에 유용하게 만드는 고유한 속성 세트를 가지고 있습니다.

이전에 이야기 한 바와 같이, **`Bool, Int, Double, String, Optional, Array`** 및 **`Dictionary`** 와 같은 모든 표준 라이브러리 타입들이 이러한 기본 타입들의 영리한 구성임은 정말 놀라운 일입니다.
이는 그들과 함께 할 수 있는 일의 힘을 말해 줍니다.

# 2️⃣ Modeling with types

이차원 기하학은 타입 시스템을 탐색하기에 적합한 문제 영역입니다.
그것은 수학적으로 잘 정의되어 있고 시각화하기 쉽기 때문입니다.

```swift
struct StructPoint {
    var x, y: Double
}

class ClassPoint {
    var x, y: Double
    init(x: Double, y: Double) { (self.x, self.y) = (x, y) }
}
```

이 두 타입 모두 x-y 평면에서의 한 점을 모델링합니다.
하지만 알아야 할 다섯 가지 본질적인 차이점들이 있습니다.

## Difference 1: Automatic initialization

**첫 번째**이자 가장 눈에 띄는 **차이점**은 **클래스 타입**에서 **초기화자(initializer)** 가 필요하다는 것입니다.
**구조체**의 경우, **초기화자**를 선언하지 않으면 컴파일러 내부 **멤버별 초기화자(member-wise initializer)** 를 선언합니다.
이 초기화자는 단순히 멤버 속성을 하나씩 할당합니다.
x와 y가 초기화 되어야 하므로 클래스에 대해서는 초기화자를 정의해야합니다.

> 📝 NOTE
> 
> 구조체에 대한 초기화자를 정의하면 컴파일러는 멤버별 초기화자를 정의하지 않습니다.
> 컴파일러가 생성한 초기화자를 모두 원한다면, 일반적인 방법은 확장(extension)에서 초기화자를 정의하는 것입니다.

## Difference 2: Copy semantics

**두 번째**로 크고 아마도 가장 중요한 차이점은 **복사 의미론(copy semantics)** 입니다.
**클래스**는 **참조 의미론(reference semantics)** 을 가지고, **구조체**는 **값 의미론(value semantics)** 을 가집니다.

**값 의미론** 은 두 인스턴스 A와 B가 주어졌을 때, A에 변경을 가함으로써 B의 값을 영향을 줄 수 없으며 그 반대의 경우도 마찬가지라고 말합니다.

**참조 의미론**을 사용하면 한 객체를 통해 다른 객체에 영향을 줄 수 있습니다.

```swift
let structPointA = StructPoint(x: 0, y: 0)
var structPointB = structPointA
structPointB.x += 10
print(structPointA.x) // 영향을 받지 않음, 0.0 출력

let classPointA = ClassPoint(x: 0, y: 0)
let classPointB = classPointA
classPointB.x += 10
print(classPointA.x) // 영향을 받음, 10.0 출력
```

**참조 의미론**을 사용하면, classPointB를 변경하면 classPointA에 **영향을 주게 됩니다.**
왜냐하면 두 변수 모두 **동일한** 기본 메모리를 가리키기 때문입니다.

이 현상은 **구조체**에서는 **발생하지 않습니다.**
**구조체**에서 structPointA와 structB는 **값 의미론**을 가진 **독립적인 복사본**입니다.

## Difference 3: Scope of mutation

Swift는 인스턴스 수준의 변이 모델(mutation model)을 지원합니다.
이는 let 키워드를 사용함으로써 인스턴스를 변이(mutation)로부터 잠글 수 있다는 의미입니다.

이것이 위의 코드에서 structPointB를 var로 선언해야 하는 이유입니다.

만약 그렇게 하지 않았다면, x좌표에 10을 더할 수 없었을 것이며, 컴파일러는 오류로 이를 방지했을 것입니다.

**classPointB를 도입하는데 let을 사용하더라도 클래스 버전에서 x좌표를 수정할 수 있다는 점에 주목하세요.**
변이 제어(mutation control)는 기본적으로 **참조 자체에 적용**되며, 그 **아래의 속성 데이터에는 적용되지 않습니다.**

### Value semantics through immutability(불변성을 통한 값 의미론)

앞서 본 예제에서 알 수 있듯이, 클래스는 참조 의미론을 가진 참조 타입입니다.
클래스에 값 의미론을 부여할 수 있을까요?
그 답은 **"예"** 이며, 가장 쉬운 방법은 **"불변성을 통한 것입니다."**

단순히 모든 속성을 **let**으로 선언하여 불변하게 만듭니다.
어디서든 **아무것도 수정할 수 없기** 때문에, 이는 **값 의미론의 정의를 만족**합니다.

함수형 언어들은 **값 의미론을 달성**하기 위해 **성능을 희생**하는 대신 **엄격한 불변성**을 자주 사용합니다.

> 📝 NOTE
> 
> Objective-C는 타입 수준의 변이 모델을 사용합니다.
> 예를 들어, NSString은 불변입니다.
> 하지만, NSMutableString은 NSString에서 파생되며 가변성을 추가합니다.
> 그러나 NSString에 대한 포인터를 가지고 있어도, 그것이 다른 클라이언트가 수정할 수 있는 NSMutableString을 가리키지 않는다는 것을 100퍼센트 확신할 수는 없습니다.
> 방어적 복사가 필요하게 되어, 이는 덜 효율적이고 덜 안전하며 더 오류가 쉬운 프로그래밍 모델이 됩니다.

StructPoint에서 x와 y 속성을 var로 선언하는 것의 아름다움은 **인스턴스**를 **var**로 선언하면 **변경 가능**하고 **let**으로 선언하면 **불변**이 될 수 있다는 것입니다.

이것이 **구조체의 속성**을 **var**로 선언하고 싶은 이유이며, **사용 시점에 각 인스턴스의 가변성을 제어**할 수 있기 때문입니다.

## Difference 4: Heap vs Stack

일반적인 규칙은 **클래스**가 **힙 메모리**를 사용하는 반면 **구조체와 열거형**은 **스택 메모리**를 사용한다는 것입니다.
**스택 할당**이 **힙 할당**보다 수백 배 **빠르기 때문에**, **값 타입이 빠르다**는 명성을 얻게 됩니다.

**각 실행 스레드**는 **자체 스택**을 가지며, **스택**은 **가장 위에 있는 요소를 수정함**으로써만 **변경**됩니다.
**결과적**으로, **스택**에 **할당**하고 **해제**하는 것은 **비싼 동시성 잠금**이나 **복잡한 할당 전략**을 **필요로 하지 않습니다.**
**할당과 해제**는 **단일 클록 틱**에서 **단일 더하기 또는 빼기 명령**으로 수행될 수 있습니다.

반면에 **힙**은 **여러 스레드에 의해 공유**되며 **동시성 잠금으로 보호**되어야 합니다.
**운영 체제**는 **다양한 크기의 메모리 블록을 할당**하고 **해제**할 때 발생할 수 있는 **힙 단편화를 방지**해야 합니다.
**결과적**으로 **힙 할당**이 매우 **최적화**되어 있음에도 불구하고, 결국 **비결정적**이며 **수행**하는 데 수천 또는 수백만 명령이 **필요**할 수 있습니다.

위 코드가 메모리에 할당될 때 어떻게 보일지에 대한 다이어그램은 다음과 같습니다.

<img src = "https://github.com/devKobe24/images/blob/main/SWDD-4.png?raw=true"></br>

구조체는 스택에 배치되는 반면, 클래스는 스택과 힙 양쪽에 배치됩니다.
힙 메모리의 참조 카운트는 참조 타입이 공유되기 때문에 객체의 수명을 추적합니다.
참조 가운트가 0으로 떨어질 때에만 deinit이 호출되고 메모리가 해제됩니다.

> 📝 NOTE
> 
> 클래스에 대한 힙과 구조체 및 열거형에 대한 스택은 단지 일반적인 지침일 뿐입니다.
> Swift 컴파일러는 모든 것을 힙에 할당한 다음 객체의 수명에 대해 추론하여 스택에 할당할 수 있는지 결정합니다.
> 예를 들어, 로컬 구조체를 포함하는 이스케이핑 클로저는 구조체의 수명을 그 범위를 넘어 연장하기 위해 힙에 해당 객체를 배치할 필요가 있습니다.
> 반면에 생성되어 어떤 작업을 수행한 후 범위를 벗어나는 클래스는 완전히 최적화되어 제거될 수 있으며, 해당 작업을 완료하는데 필요한 지시사항만 포함할 수 있습니다.

## Difference 5: Lifetime and identity(수명과 정체성)

구조체와 열거형과 같은 값 타입은 일반적으로 스택에 존재하며 복사하는 데 비용이 적게 듭니다.
값에는 수명이나 본질적인 정체성의 개념이 없습니다.

참조에는 수명이 있으며, 그 때문에 deinit 함수를 정의할 수 있습니다.
또한, 메모리의 특정 위치에 존재하기 때문에 자동으로 정체성을 가지며, 이를 사용하여 식별할 수 있습니다.

> 📝 NOTE
> 
> 고유한 속성(property) 속성(attribute)을 지정함으로써 값 타입에 정체성을 부여할 수 있습니다.
> Hashable(및 Equatable) id 속성을 추가하는 Identifiable 프로토콜이 이를 수행합니다.
> SwiftUI 프레임워크는 `@State` 왁 같은 속성 래퍼를 정의하는데, 이러한 것들은 간단한 값 타입에 수명을 부여하는 것을 포함합니다.

## More Differences

이 간단한 예제로는 밝혀지지 않는 클래스와 구조체 사이의 다른 차이점들이 있습니다.
가장 두드러진 차이점 중 하나는 클래스가 런타임 다형성을 실현하기 위해 사용하는 상속입니다.
클래스는 동적으로 메소드를 디스패치하는 반변, 프로토콜을 사용하지 않는 한 구조체에서는 이러한 일이 발생하지 않습니다.
프로토콜에 속하지 않는 구조체 메소드에 대해서는 디스패치가 정적으로 일어납니다.

> 📝 NOTE
> 
> 클래스의 메소드를 final로 표시할 수 있는데, 이는 가상화를 해제하고 실행 속도를 빠르게 만드는 부수 효과가 있을 수 있습니다.
> 컴파일러는 접근 제어와 전체 모듈 최적화에서 얻은 힌트를 사용하여 메소드가 오버라이드될 수 없다는 것을 증명하고 최적화할 수 있습니다.

## Defining a Point(포인트 정의)

위에서 언급된 차이점들을 고려할 때, Point를 가볍게 표현하는 값 타입을 사용하는 것이 좋은 선택일 것 같습니다.

이 설계를 사용하십시오.

```swift
struct Point: Equatable {
    var x, y: Double
}

struct Size: Equatable {
    var width, height: Double
}

struct Rectangle: Equatable {
    var origin: Point
    var size: Size
}
```

이는 Point, Size 및 Rectangle을 Equatable 준수와 함께 정의합니다.

값 타입의 경우, 저장된 속성들도 Equatable 타입이라면 컴파일러가 필요한 `==` 메소드를 자동으로 생성해줍니다.

참조 타입(즉, 클래스)은 Equatable에 대한 `==` 및 Hashable의 `hash(into:)`를 직접 작성해야 합니다.

값 의미론의 또 다른 중요한 특징은 그것이 구성 가능하다는 것입니다.
Rectangle은 값 타입이며 Point와 Size 모두 값 의미론을 가지고 있기 때문에 값 의미론을 가집니다.
더 나아가 Swift 배열은 값 의미론을 가지므로, Rectangle의 배열 역시 값 의미론을 가질 것입니다.

> 📝 NOTE
> 
> 코드 합성은 컴파일러의 타입 체킹 단계에서 발생합니다.
> 프로토콜을 채택할 때, 컴파일러는 타입이 프로토콜을 충족(증명)하는지 확인합니다.
> 그렇지 않으면 일반적으로 오류를 발생시킵니다.
> Equatable의 특별한 경우에는, 타입이 값 타입이고 저장된 모든 속성들이 Equatable이라면 `==`를 합성하려고 시도합니다.
> Hashable, Codable 및 CaseIterable에 대해서도 비슷한 과정이 일어납니다.
> 다른 것들과 달리, Codable은 값 타입과 참조 타입 모두에 대한 코드를 합성합니다.

---

# ✅ 1. "동시성 잠금(Concurrency Lock)"

**"동시성 잠금(Concurrency Lock)"** 은 **멀티스레딩 환경에서 데이터의 일관성과 무결성을 유지하기 위해 사용되는 동기화 메커니즘입니다.**

여러 스레드가 동시에 같은 데이터에 접근하고 수정할 때 동시성 잠금을 사용하여 한 번에 하나의 스레드만 해당 데이터 또는 자원에 접근할 수 있도록 제한합니다.

## ✅ 1.1 동시성 잠금의 주요 목적.

### 1. 데이터 경쟁 방지(Data Race Prevention).

데이터 경쟁은 두 개 이상의 스레드가 동시에 같은 데이터에 접근하고 적어도 하나의 스레드가 데이터를 수정할 때 발생합니다.

동시성 잠금은 이러한 경쟁 조건을 방지하여 데이터의 무결성을 보장합니다.

### 2. 동시 접근 관리(Concurrent Access Management).

잠금을 사용하여 데이터에 대한 동시 접근을 제어함으로써, 복잡한 멀티스레딩 애플리케이션의 동작을 더 예측 가능하고 안정적으로 만듭니다.

## 💯 1.2 동시성 잠금 마무리.

동시성 잠금에는 여러 형태가 있으며, 가장 일반적인 형태로는 뮤텍스(Mutex), 세마포어(Semaphore), 모니터(Monitor) 등이 있습니다.

각각의 스레드간의 동기화와 자원 접근을 관리하는 데 사용되며, 특정 상황에 적합한 메커니즘을 선택하여 사용합니다.

그러나 동시성 잠금 사용에는 주의가 필요합니다.
잘못 사용하면 교착 상태(Deadlock), 라이브락(Livelock) 스타베이션(Starvation)과 같은 문제들이 발생할 수 있으며, 이는 애플리케이션의 성능과 안정성에 부정적인 영향을 미칠 수 있습니다.

따라서 동시성 프로그래밍은 신중하게 설계하고 구현해야 합니다.

# ✅ 2. 클래스는 Heap과 Stack 어디에 배치될까?

Swift에서 클래스의 인스턴스는 주로 힙(Heap) 메모리에 배치됩니다.
하지만 클래스 자체에 관련된 참조는 스택(Stack) 메모리에 저장될 수 있습니다.

이것이 **"클래스가 스택과 힙 양쪽에 배치된다"** 고 표현되는 이유입니다.

## ✅ 2.1 클래스 인스턴스가 힙에 저장되는 방식.

### 1. 힙 메모리(Heap memory).

클래스 인스턴스의 실제 데이터는 힙에 저장됩니다.
힙은 동적으로 할당되는 메모리 영역으로, 크기가 커지거나 줄어드는 객체와 같이 런타임에 크기가 변할 수 있는 데이터를 저장하는데 적합합니다.

### 2. 스택 메모리(Stack memory).

클래스 인스턴스를 가리키는 참조(포인터)는 스택에 저장됩니다.
스택은 함수 호출과 로컬 변수에 사용되는 메모리 영역으로, 프로그램의 실행 흐름에 따라 자동으로 관리됩니다.

# 💯 2. 클래스는 Heap과 Stack 어디에 배치될까? 정리.

예를 들어, 클래스의 인스턴스를 생성하고 이를 변수에 할당하는 경우, 인스턴스 데이터는 힙에 저장되고,
그 인스턴스를 가리키는 참조는 함수가 호출된 스택 프레임 내의 변수에 저장됩니다.

이 방식은 참조 타입의 특성을 반영합니다.
참조 타입은 데이터가 힙에 저장되고, 이 데이터에 대한 참조를 통해 여러 곳에서 공유하고 접근할 수 있도록 합니다.
이는 값 타입과 대조되는데, 값 타입(예: 구조체, 열거형)은 일반적으로 스택 메모리에 직접 저장됩니다.

--- 

### 참고 자료 📚

- [Stack](https://github.com/devKobe24/CS/blob/main/Kobe/231130-stack.md)
