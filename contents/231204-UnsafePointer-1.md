# UnsafePointer(1) 🤿

**"A raw pointer for accessing untyped data."**
유형화되지 않은 데이터에 액세스하기 위한 원시 포인터입니다.

- Swift와 같은 고급 프로그래밍 언어에서도 낮은 수준의 메모리 접근을 위한 원시 포인터 사용을 지원한다는 것을 나타냅니다.
    - 이러한 기능은 일반적으로 안전한 타입 시스템을 벗어나기 때문에 주의 깊게 사용해야 합니다.

### 🤔 문장 의미 뜯어 먹기 냠냠 🍗

1. **Raw Pointer(원시 포인터)**
**"원시 포인터"** 는 메모리의 특정 위치를 가리키는 포인터로, 그 메모리에 저장된 타입에 대한 정보가 없습니다.
즉, **원시 포인터**는 단순히 바이트의 연속으로 저장된 데이터를 가리킵니다.

2. **Untyped Data(비타입화된 데이터)**
**`Untyped data`** 는 특정 데이터 타입이 지정되지 않은 상태를 의미합니다.
일반적인 프로그래밍에서 변수나 객체는 특정 타입(Int, String 등)을 가지지만, **원시 포인터**가 가리키는 데이터는 어떤 구체적인 데이터 타입의 형태도 취하지 않습니다.
**이 데이터**는 구조체, 배열, 문자열 또는 다른 복잡한 데이터 타입이 될 수 있지만, **포인터 자체**는 그 데이터의 타입에 대해 아무런 가정도 하지 않습니다.

3. **Accessing Data(데이터 접근)**
**원시 포인터**를 사용하여 메모리에 직접 접근하고 데이터를 읽거나 쓸 수 있습니다.
이는 낮은 수준의 메모리 조작을 가능하게 하며, 특정 상황에서는 성능 최적화나 시스템 레벨 프로그래밍에 필수적일 수 있습니다.

```swift
@frozen
struct UnsafeRawPointer
```

## ✅ Overview.

📝 **`UnsafeRawPointer`** 타입은 자동 메모리 관리, 타입 안전성, 정렬 보장을 제공하지 않습니다.
안전하지 않은 포인터를 통해 작업하는 모든 메모리의 생명주기를 관리하는 것은 개발자 자신의 책임입니다.
이를 통해 메모리 누수나 정의되지 않은 행동을 피할 수 있습니다.

### 🍗 문장 의미 뜯어 먹기 냠냠

1. **자동 메모리 관리 부재.**
**`UnsafeRawPointer`** 는 자동 메모리 관리를 제공하지 않습니다.
Swift의 일반적인 변수나 객체는 자동 참조 카운팅(ARC)을 통해 메모리 관리가 이루어지지만,
**`UnsafeRawPointer`** 를 사용할 때는 개발자가 직접 메모리를 할당하고 해제해야 합니다.

2. **타입 안전성 부재.**
**`UnsafeRawPointer`** 는 타입 안전성을 제공하지 않습니다.
이 포인터는 어떠한 타입의 데이터도 가리킬 수 있으며, 
포인터를 통해 접근하는 데이터의 실제 타입을 컴파일러가 검증할 수 없습니다.
따라서 개발자는 데이터를 올바르게 해석하고 사용할 책임이 있습니다.

3. **정렬 보장 부재.**
이 포인터는 메모리의 정렬(alignment)을 보장하지 않습니다.
데이터의 정렬은 특정 타입의 데이터가 메모리 상에서 어떻게 배치되는지를 나타내며, 
잘못된 정렬은 프로그램의 오류나 성능 저하를 일으킬 수 있습니다.

4. **메모리 생명주기 관리 책임.**
**`UnsafeRawPointer`** 를 사용하는 개발자는 메모리 누수(leaks)나 정의되지 않은 행동(underfined behavior)을 피하기 위해 메모리의 생명주기를 직접 관리해야 합니다.
이는 메모리 할당과 해제를 적절히 수행해야 함을 의미합니다.

5. **요약.**
**`UnsafeRawPointer`** 는 Swift에서 제공하는 낮은 수준의 메모리 접근 수단이며, 고급 수준의 안전성이나 메모리 관리 기능을 제공하지 않습니다.
따라서 이를 사용할 때는 메모리 관리, 타입 안전성, 데이터 정렬 등에 대한 추가적인 주의가 필요합니다.

> 🤔 메모리의 정렬(alignment)란 어떤 의미인가요?
> 
> 🙋‍♂️ **"메모리의 정렬(alignment)"** 은 컴퓨터 메모리에서 데이터가 저장되는 방식과 관련된 개념입니다.
> 
> 특히, 데이터가 메모리상에서 어떤 주소 경계에 배치되는지를 나타냅니다.
> 
> **정렬**은 데이터의 읽기와 쓰기 효율성, 성능 및 하드웨어 요구사항과 밀접하게 관련되어 있습니다.
> 
> 🙋‍♂️ **정렬의 의미**에 대해서 알아볼까요?!
> 
> **1. 주소 경계.**
> 메모리 정렬은 데이터가 시작되는 메모리 주소가 특정 크기의 배수가 되도록 하는 것을 의미합니다.
> 예를 들어, 4바이트 정렬된 데이터는 4의 배수인 메모리 주소에 위치합니다.
> 
> **2. 효율성과 성능.**
> 잘 정렬된 데이터는 컴퓨터 시스템에서 더 효율적으로 접근하고 처리할 수 있습니다.
> 잘못 정렬된 데이터에 접근하려면 추가적인 계산과 메모리 접근이 필요할 수 있어 성능 저하를 일으킬 수 있습니다.
> 
> **3. 하드웨어 요구사항.**
> 일부 하드웨어 아키텍처는 특정 타입의 데이터에 대해 엄격한 정렬 요구사항을 갖습니다.
> 이를 무시하면 하드웨어 오류나 예외가 발생할 수 있습니다.
> 
> 🙋‍♂️ **정렬의 예시를 보여줄게요!!**
> 
> - **4바이트 정렬 :** 4바이트 크기의 정수는 4의 배수인 곳에 저장됩니다(예: 0x1004, 0x1008)
> - **자연 정렬 :** 데이터 타입의 크기에 따라 자동으로 정렬되는 것을 의미합니다. 예를 들어, 8바이트 데이터는 8의 배수인 주소에 배치됩니다.
> 
> 🙋‍♂️ **프로그래밍에서의 정렬의 의미도 있어요!!**
> 
> 프로그래밍 언어와 시스템은 보통 데이터 타입에 대한 기본 정렬을 가지고 있습니다.
> 하지만 낮은 수준의 프로그래밍에서는 개발자가 직접 메모리 정렬을 관리해야 할 수도 있습니다.
> 예를 들어, C/C++에서는 **`alignof`** 또는 **`aligned_alloc`** 같은 연산자와 함수를 통해 데이터 정렬을 제어할 수 있답니다!!

📝 직접 관리하는 메모리는 타입이 지정되지 않았거나 특정 타입에 바인딩될 수 있습니다.
메모리가 특정 타입에 바인딩되었는지 여부와 관계없이, **`UnsafeRawPointer`** 타입을 사용하여 메모리의 원시 바이트에 접근하고 관리합니다.

### 🍗 문장 의미 뜯어 먹기 냠냠

1. **직접 관리하는 메모리.**
개발자가 메모리 할당과 해제를 직접 관리하는 경우를 말합니다.
이는 고급 언어의 자동 메모리 관리 시스템(예: ARC,자동 참조 카운팅)을 사용하지 않는 상황입니다.

2. **타입이 지정되지 않은(untyped) 메모리.**
이는 메모리가 특정 데이터 타입에 바인딩되지 않았음을 의미합니다.
즉, 메모리의 내용이 어떤 구체적인 데이터 타입으로 해석되지 않은 상태를 말합니다.

3. **특정 타입에 바인딩된 메모리.**
이는 메모리가 특정 데이터 타입(예: Int, String 등)으로 해석될 수 있도록 설정된 경우를 말합니다.

4. **`UnsafeRawPointer`의 사용.**
**`UnsafeRawPointer`** 는 Swift에서 제공하는 타입으로, 메모리의 원시 바이트에 접근하기 위해 사용됩니다.
이 타입을 사용하면 메모리가 어떤 특정 타입에 바인딩 되었는지와 관계없이, 메모리의 원시 데이터에 접근하고 이를 관리할 수 있습니다.

5. **요약.**
메모리를 직접 관리하는 상황에서 **`UnsafeRawPointer`** 를 사용하여 원시 메모리 데이터에 접근하고 이를 처리하는 방법을 설명하고 있습니다.
이는 낮은 수준의 프로그래밍, 특히 메모리와 관련된 직접적인 조작이 필요한 경우에 해당합니다.

---

## ✅ Understanding a Pointer's Memory State(포인터의 메모리 상태 이해)

📝 **`UnsafeRawPointer`** 인스턴스가 참조하는 메모리는 여러 상태 중 하나일 수 있습니다.
많은 포인터 연산은 특정 상태의 메모리에만 적용되어야 하므로, 작업 중인 메모리의 상태를 추적하고 다양한 연산이 그 상태에 어떤 변화를 주는지 이해해야 합니다.

메모리는 타입이 지정되지 않고 초기화되지 않았거나, 타입에 바인딩되었지만 초기화되지 않았거나, 타입에 바인딩되어 값으로 초기화되었을 수 있습니다.

마지막으로, 이전에 할당된 메모리가 해제되어 기존 포인터들이 할당되지 않은 메모리를 참조하게 될 수도 있습니다.

### 🍗 문장 의미 뜯어 먹기 냠냠

1. **메모리의 다양한 상태.**
**`UnsafeRawPointer`** 에 의해 참조되는 메모리는 여러 상태를 가질 수 있습니다.
이 상태들에는 다음과 같은 것들이 포함됩니다.
    - **타입이 지정되지 않고 초기화되지 않은 상태 :** 메모리가 아직 어떤 특정 타입으로 지정되지 않았으며, 아무런 값으로 초기화되지 않은 상태입니다.
    - **타입에 바인딩되었지만 초기화되지 않은 상태 :** 메모리가 특정 타입에는 바인딩되었지만, 아직 초기화되지 않은 상태입니다.
    - **타입에 바인딩되어 값으로 초기화된 상태 :** 메모리가 특정 타입에 바인딩되고, 특정 값으로 초기화된 상태입니다.

2. **메모리 상태의 중요성.**
메모리의 상태에 따라 적용할 수 있는 포인터 연산이 달라집니다.
따라서 개발자는 작업 중인 메모리의 현재 상태를 정확히 파악하고, 다양한 연산이 메모리 상태에 어떤 변화를 주는지 이해해야 합니다.

3. **메모리 할당 및 해제.**
이전에 할당되었던 메모리가 해제될 수도 있으며, 이 경우 기존 포인터들은 할당 해제된,
즉 더 이상 유효하지 않은 메모리를 참조하게 됩니다.
이는 미사용 메모리를 참조하는 포인터로 인한 오류나 취약점을 초래할 수 있습니다.

4. **요약**
메모리 관리와 관련된 낮은 수준(low-level)의 프로그래밍, 특히 메모리에 직접 접근하는 경우에 해당하며,
메모리의 안전한 관리와 올바른 사용을 위한 중요한 지침을 제공합니다.

### ✅ Raw, Unititialized Memory(초기화되지 않은 원시 메모리)

📝 방금 할당된 원시 메모리는 초기화되지 않고 타입이 지정되지 않은 상태입니다.
초기화되지 않은 메모리는 타입별 연산을 사용하기 전에 특정 타입의 값으로 초기화되어야 합니다.

초기화하지 않고 초기화되지 않은 메모리를 특정 타입에 바인딩하려면,
**`bindMemory(to:count)`** 메서드를 사용하세요.
이 메서드는 메모리에 대한 추가적인 타입별 접근을 위한 타입이 지정된 포인터를 반환합니다.

### 🍗 문장 의미 뜯어 먹기 냠냠

1. **할당된 원시 메모리의 상태.**
새롭게 할당된 원시 메모리(raw memory)는 초기화되지 않은(uninitialized) 상태이며,
특정 타입(type)이 지정되지 않은(untyped) 상태입니다.
즉, 메모리는 할당되었지만 아직 어떤 데이터 타입의 값으로도 채워지지 않은 상태입니다.

2. **메모리 초기화의 필요성.**
초기화되지 않은 메모리는 사용되기 전에 특정 타입의 값으로 초기화되어야 합니다.
메모리가 타입에 따른 값으로 초기화되지 않으면, 해당 메모리에 대한 타입별(type-specific) 연산을 수행할 수 없습니다.

3. **메모리를 타입에 바인딩하는 방법.**
**`bindMemot(to:count:)`** 메서드를 사용하면, 메모리를 초기화하지 않고 특정 타입에 바인딩할 수 있습니다.
이는 메모리에 타입을 할당하지만, 아직 해당 타입의 값으로 채우지는 않습니다.

4. **타입이 지정된 포인터 반환.**
**`bindMemory(to:count:)`** 메서드는 타입이 지정된 포인터(typed pointer)를 반환합니다.
이 포인터를 사용하여 추후에 해당 메모리에 대한 타입별 접근을 수행할 수 있습니다.

5. **요약.**
메모리를 할당한 후, 그 메모리를 사용하기 전에 필요한 초기화 및 타입 바인딩 과정에 대하여 설명하고 있으며,
이러한 과정은 프로그램에서 메모리를 직접 관리하는 경우, 특히 시스템 프로그래밍이나 성능 최적화가 필요한 상황에서 중요합니다.

### ✅ Typed Memory(유형화된 메모리)

📝 타입에 바인딩된 메모리는 초기화되었든 아니든, 일반적으로 타입이 지정된 포인터 **`UnsafePointer`** 및 **`UnsafeMutablePointer`** 의 인스턴스를 사용하여 접근하게 됩니다.
초기화, 할당 그리고 해제는 **`UnsafeMutablePointer`** 메서드를 사용하여 수행할 수 있습니다.

특정 타입에 바인딩된 메모리는 그 메모리가 해제되었거나 바인딩된 타입이 단순한(trivial) 타입인 경우에만 다른 타입으로 재바인딩될 수 있습니다.

타입이 지정된 메모리를 해제해도 그 메모리의 타입 바인딩은 해제되지 않습니다.
해제된 메모리는 동일한 타입의 값으로 다시 초기화되거나, 새로운 타입에 바인딩되거나, 할당 해제될 수 있습니다.

> 📝 Note
> 
> 단순한 타입은 간접 참조나 참조 카운팅 작업 없이 비트 단위로 복사될 수 있는 타입을 의미합니다.
> 일반적으로 강한 참조나 약한 참조, 또는 기타 형태의 간접 참조를 포함하지 않는 네이티브 Swift 타입들과 C에서 가져온 구조체 및 열거형은 단순한 타입으로 간주됩니다.

특정 타입에 바인딩된 메모리를 원시 바이트로 읽을 때는 해당 메모리의 정렬 요구사항을 충족시켜야 합니다.

### 🍗 문장 의미 뜯어 먹기 냠냠

1. **타입에 바인딩된 메모리 접근.**
타입에 바인딩된 메모리(초기화된 상태이든 아니든)는 일반적으로 타입이 지정된 포인터를 통해 접근됩니다.
이는 **`UnsafePointer`** 와 **`UnsafeMutablePointer`** 인스턴스를 의미합니다.
**`UnsafeMutablePointer`** 메서드를 사용하여 메모리의 초기화, 할당, 해제 등을 수행할 수 있습니다.

2. **메모리 재바인딩 조건.**
특정 타입에 바인딩된 메모리는 해제되었거나 바인딩된 타입이 단순한(trivial) 타입인 경우에만 다른 타입으로 재바인딩될 수 있습니다.
타입에 따른 메모리 해제는 메모리의 타입 바인딩을 해제하지 않습니다.

3. **해제된 메모리의 재사용.**
해제된 메모리는 동일한 타입의 값으로 다시 초기화하거나, 새로운 타입에 바인딩하거나, 완전히 할당 해제할 수 있습니다.

4. **단순한 타입의 정의.**
단순한 타입은 간접 참조나 참조 카운팅 작업 없이 비트 단위로 복사될 수 있는 타입입니다.
Swift의 네이티브 타입 중 강한 참조나 약한 참조, 기타 간접 참조를 포함하지 않는 타입들과 C에서 가져온 구조체 및 열거형이 이에 해당합니다.

5. **메모리 읽기와 정렬 요구사항.**
특정 타입에 바인딩된 메모리를 원시 바이트로 읽을 때는 해당 메모리의 정렬 요구사항을 충족해야 합니다.

6. **요약.**
메모리를 타입에 바인딩하는 방법, 메모리를 다른 타입으로 재바인딩하는 조건, 그리고 타입에 바인딩된 메모리를 안전하게 읽기 위한 정렬 요구사항, 이러한 개념은 낮은 수준의 시스템 프로그래밍이나 성능에 민감한 응용 프로그램 개발에 중요합니다.

---

### 참고자료 📚

- [🍎🧑‍💻📝Apple Developer Documentation - UnsafeRawPointer](https://developer.apple.com/documentation/swift/unsaferawpointer)
