# Core Concepts(1): Easy onboarding, Multi-paradigm 🧑‍💻

## 1️⃣ Easy onboarding.

Swift는 점진적 공개 철학을 채택하고 있으므로 필요한 언어의 복잡성만 접할 수 있습니다.

모듈, 접근 제어, 객체, 정적 메서드, 프로토콜, 제네릭, 이스케이프 문자 등 여러분이 하려는 작업에 필요한 것들을 필요에 따라 배울 수 있습니다.

또한 Swift에서는 아래와 같은 기능을 바로 사용할 수 있습니다.

```swift
import Foundation

let pointer = malloc(100)
defer {
	free(pointer)
}

// work with raw memory
```

Swift는 저수준 C와 Python과 같은 스크립팅 환경 간의 원활한 상호 운용성을 지원할 수 있습니다.

## 2️⃣ Multi-paradigm

애플은 그 첫 WWDC에서 Swift의 현대적인 언어 기능을 시연했습니다.
첫 번째 실시간 데모에서는 문자열을 SpriteKit 이미지로 함수적으로 매핑했습니다.

UIKit, CoreData, SpriteKit 과 같은 거대한 레거시 객체 지향 프레임워크를 다루는 것 외에도 Swift는 `map`, `reduce`, `filter`를 사용하여 값의 시퀀스와 함수적으로 대화할 수 있습니다.

숫자 시퀀스를 더해 비교하고 싶은 문제를 고려해 보십시오.
명령형과 함수형 스타일로 비교할 수 있습니다.

아래의 코드를 봐봅시다.

```swift
import Foundation

public func example(_ title: String,
                    code: () throws -> Void) rethrows {
  print("## \(title)")
  try code()
  print("---")
}

let numbers = [1, 2, 4, 10, -1, 2, -10]

example("명령형") {
	var total = 0
	for value in numbers {
		total += value
	}
	print(total)
}

// 출력
// ## 명령형
// 8
// ---
```

예제 제목이 시사하듯이, 이 코드는 숫자들을 더하고 결과를 변경 가능한 변수 `total`에 저장합니다.

이제 함수형 버전을 추가해봅시다.

```swift
example("함수형") {
	let total = numbers.reduce(0, +)
	print(total)
}

// 출력
// ## 함수형
// 8
// ---
```

이 함수형 버전은 매우 간단합니다.
이 메소드는 설명적이며, 나중에 코드에서 변경할 필요가 없는 불변값으로 `total`을 허용합니다.

경험에 따르면 함수형으로 가는 것이 코드에 유익할 수 있습니다.

왼쪽에서 오른쪽으로 숫자 시퀀스를 더하되, 음수가 나타나면 중단하는 것이 과제입니다.

하나의 가능한 함수형 버전은 다음과 같을 수 있습니다.

```swift
example("함수형, 조기 종료") {
	let total = numbers.reduce((accumulating: true, total: 0)) { (state, value) in
		if state.accumulating && value >= 0 {
			return (accumulating: true, state.total + value)
		}
		else {
			return (accumulating: false, state.total)
		}
	}.total
	print(total)
}
// 출력
// ## 함수형, 조기 종료
// 17
// ---
```

이 코드는 더 복잡하지만 동일한 `reduce` 함수를 호출하고 값이 누적되는지와 실행 중인 총합을 제어하는 튜플을 사용합니다.
컴파일러가 조기 종료가 가능하다는 것을 파악하기 위해 열심히 일해야 합니다.
실제로 현재의 Swift 컴파일러는 이를 아직 유추할 수 없으며 `numbers` 배열의 모든 요소를 반복합니다.

더 영리한 방법으로 이 문제를 함수형으로 해결할 수 있지만(예를 들어, `reduce` 하기 전에 지연 시퀀스를 사용하는 것과 같은), 명령형으로 직접적으로 문제를 해결할 수 있습니다.

```swift
example("명령형, 조기 종료") {
	var total = 0
	
	for value in numbers {
		guard value >= 0 else { break }
		total += value
	}
	print(total)
}
// 출력
// ## 명령형, 조기 종료
// 17
// ---
```

이 코드는 문제 진술을 더 직접적으로 설명하기 때문에 따라하기 쉽습니다.
또한 CPU 명령어에 더 직접적으로 매핑되므로 최적화기(Optimizer)가 조기 종료를 쉽게 최적화할 수 있습니다.

위 코드의 단점은 `total`이 변경가능한 변수로 누출된다는 것입니다.
나중에 변수가 어떻게 변경될 수 있는지와 그 수명을 추적해야 합니다.

그러나 Swift의 변형 모델(`Swift mutation model`) 덕분에 이를 해결할 수 있습니다.

```swift
example("명령형, 조기 종료와 적시 변형성") {
	let total: Int = {
		// 동일한 오래된 명령형 코드
		var total = 0
		for value in numbers {
			guard value >= 0 else { break }
			total += value
		}
		return total
	}()
	print(total)
}
// 출시
// ## 명령형, 조기 종료와 적시 변형성
// 17
// ---
```

이 코드는 명령형 코드를 클로저로 감싸고 바깥쪽 불변 `total`에 할당하기 위해 호출합니다.
이 방법으로 Swift는 "필요할 때만 변형"을 제공합니다.
이것은 자연스러운 해결책일 때 지역 변형(local mutation)을 사용하여 알고리즘을 표현할 수 있게 해줍니다.

### 🍗 문장 뜯어 먹기 냠냠 (1)

> "문자열을 SpriteKit 이미지로 함수적으로 매핑했습니다."

🙋‍♂️ 이 문장은 문자열(텍스트 데이터)을 SpriteKit 이미지(그래픽 이미지)로 변환하는 과정을 '함수적으로'
즉, 함수형 프로그래밍 방식을 사용하여 수행한다는 것을 의미합니다.

🙋‍♂️ 함수형 프로그래밍은 데이터 변환과 처리를 '함수'라는 개념을 중심으로 하는 프로그래밍 패러다임입니다.
이 경우, 문자열을 입력받아 이를 이미지로 변환하는 함수가 있을 것이며, 이 함수는 각 문자열을 해당하는 이미지로 "매핑(mapping)"
즉,연결하는 역할을 합니다.
SpriteKit은 애플의 게임 개발을 위한 프레임워크로, 이러한 매핑을 통해 텍스트 데이터를 시각적인 게임 요소로 변환하는 과정이 될 수 있습니다.

🙋‍♂️ 간단히 말해, 이 문장은 Swift 언어가 문자열 데이터를 그래픽 이미지로 변환하는 과정을 함수형 프로그래밍 방식으로 쉽고 효율적으로 수행할 수 있다는 것을 나타냅니다.

### 🍗 문장 뜯어 먹기 냠냠 (2)

> "UIKit, CoreData, SpriteKit 과 같은 거대한 레거시 객체 지향 프레임워크를 다루는 것"

🙋‍♂️ 이 문장은 Swift 프로그래밍 언어가 이러한 크고 복잡한 객체 지향 프레임워크들과 호환되고, 그들을 효과적으로 사용할 수 있다는 것을 의미합니다.

각각의 프레임워크를 살펴보면 다음과 같습니다.

1️⃣ **UIKit :** iOS 애플리케이션의 사용자 인터페이스를 구축하기 위한 프레임워크입니다. 버튼, 슬라이더, 텍스트 입력 필드와 같은 사용자 인터페이스 요소를 포함합니다.

2️⃣ **CoreData :** 데이터 저장과 관리를 위한 프레임워크입니다. 주로 iOS 및 macOS 애플리케이션에서 사용되며, 앱 내에서의 데이터 모델링 및 지속성 관리를 담당합니다.

3️⃣ **SpriteKit :** 주로 2D 게임 개발을 위해 사용되는 프레임워크입니다. 그래픽, 애니메이션 및 물리적 상호작용을 쉽게 구현할 수 있게 해줍니다.

🙋‍♂️ 이 문장에서 "레거시(Legacy)" 라는 용어는 이러한 프레임워크들이 오래전부터 존재하고, 시간이 지남에 따라 많은 코드와 복잡성을 축적했다는 것을 의미합니다.
객체 지향 프로그래밍은 클래스와 객체를 중심으로 하는 프로그래밍 방식으로, 코드의 재사용성과 확장성을 높이는 데 유용합니다.

🙋‍♂️ 따라서 이 문장은 Swift가 이러한 복잡하고 오래된 객체 지향 프레임워크들을 지원하고, 개발자가 이들을 사용하여 애플리케이션을 개발할 수 있음을 나타냅니다.
Swift는 모던한 언어 특성과 함께 기존의 복잡한 시스템을 효율적으로 처리할 수 있는 능력을 가지고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠 (3)

> Swift는 `map`, `reduce`, `filter`를 사용하여 값의 시퀀스와 함수적으로 대화할 수 있습니다.

🙋‍♂️ 이 문장은 Swift 프로그래밍 언어가 `map`, `reduce`, `filter`와 같은 함수형 프로그래밍 기법을 사용하여 데이터 컬렉션을 효과적으로 처리할 수 있다는 것을 의미합니다.
이들 함수는 Swift에서 배열이나 다른 컬렉션 타입의 데이터를 다룰 때 중요한 역할을 합니다.

1️⃣ **`map` :** 이 함수는 컬렉션의 각 요소에 대해 주어진 함수를 적용하고, 그 결과를 새로운 컬렉션으로 반환합니다.
예를 들어, 모든 숫자들의 제곱을 계산하거나, 문자열 배열의 모든 요소를 대문자로 변환하는 등의 작업에 사용됩니다.

2️⃣ **`reduce` :** 이 함수는 컬렉션의 모든 요소를 단일 값으로 결합하는 데 사용됩니다.
예를 들어, 숫자 배열의 총합을 계산하거나 문자열 배열을 하나의 연결된 문자열로 결합하는 데 사용할 수 있습니다.

3️⃣ **`filter` :** 이 함수는 주어진 조건에 맞는 요소만을 포함하는 새로운 컬렉션을 생성합니다.
예를 즐어, 특정 조건을 충족하는 숫자들만 선택하거나 특정 기준을 만족하는 요소들만 필터링하는 데 사용됩니다.

🙋‍♂️ 이러한 함수들은 '함수적 대화' 또는 함수형 프로그래밍 방식으로 컬렉션을 처리한다는 개념을 나타냅니다.
이 방식은 코드의 간결성과 가독성을 높이며, 부수 효과를 줄이고 코드의 예측 가능성을 증가시킬 수 있습니다.
Swift가 이러한 기능을 지원함으로써, 개발자는 보다 표현력 있고 간결한 방식으로 데이터를 처리할 수 있게 됩니다.

### 🍗 문장 뜯어 먹기 냠냠 (4)

> 왼쪽에서 오른쪽으로 숫자 시퀀스를 더하되, 음수가 나타나면 중단하는 것이 과제입니다.

🙋‍♂️ 이 문장은 프로그래밍 문제나 과제의 설명입니다.
여기성의 목표는 숫자의 시퀀스(일련의 숫자들)를 순차적으로 더하는 것이며, 기 과정은 왼쪽(시퀀스의 시작 부분)에서 시작하여 오른쪽(시퀀스의 끝 부분)으로 진행됩니다.
하지만, 중요한 조건은 시퀀스 내에서 음수가 나타나는 순간 더하는 작업을 중단한다는 것입니다.

이 문제는 다음과 같이 구현될 수 있습니다.

1️⃣ 시퀀스의 첫 번째 요소부터 시작하여 각 요소를 순서대로 더합니다.

2️⃣ 순차적으로 더하는 도중에 음수가 등장하면, 그 시점에서 더하기 작업을 멈추고, 그때까지의 합계를 결과로 반환합니다.

🙋‍♂️ 예를 들어, 숫자 시퀀스가 **`[1, 2, 4, -3, 5]`** 인 경우, 프로그램은 **1+2+4**까지 계산하고, **-3**이 나타났을 때, 중단하여 총합 **7**을 결과로 내놓습니다.
이러한 문제는 프로그래밍에서 조건부 반복, 루프 제어, 조건문 등의 기본적인 개념을 사용하여 해결할 수 있습니다.
Swift와 같은 현대 프로그래밍 언어를 사용하면 이러한 유형의 문제를 더욱 효율적이고 간결하게 해결할 수 있습니다.

### 🍗 문장 뜯어 먹기 냠냠 (5)

```swift
example("함수형, 조기 종료") {
	let total = numbers.reduce((accumulating: true, total: 0)) { (state, value) in
		if state.accumulating && value >= 0 {
			return (accumulating: true, state.total + value)
		}
		else {
			return (accumulating: false, state.total)
		}
	}.total
	print(total)
}
// 출력
// ## 함수형, 조기 종료
// 17
// ---
```

>이 코드는 더 복잡하지만 동일한 `reduce` 함수를 호출하고 값이 누적되는지와 실행 중인 총합을 제어하는 튜플을 사용합니다.
컴파일러가 조기 종료가 가능하다는 것을 파악하기 위해 열심히 일해야 합니다.
실제로 현재의 Swift 컴파일러는 이를 아직 유추할 수 없으며 `numbers` 배열의 모든 요소를 반복합니다.

🙋‍♂️ 제시된 Swift 코드와 설명은 함수형 프로그래밍 접근 방식을 사용하여 특정 조건 하에 숫자 시퀀스의 합을 계산하는 방법을 보여줍니다.

🙋‍♂️ 구체적으로 위 제시된 코드는 `reduce` 함수를 사용하여 음수나 값이 나타날 때까지 시퀀스의 숫자들을 누적하여 합산하는 과정을 구현합니다.

🧑‍💻 **코드 분석**

1️⃣ **`reduce`** 함수는 초기 상태 **`(accumulating: true, total: 0)`** 와 함께 시작합니다.
여기에서 **`accumlating`** 은 누적이 계속되는지 여부를 나타내고, **`total`** 은 누적 합계를 나타냅니다.

2️⃣ **`reduce`** 의 클로저는 각 숫자에 대해 실행됩니다. 만약 현재 상태가 누적 중이고(**`accmulating`** 이 **`true`**), 그 값이 음수가 아니면(**`value >= 0`**), 새로운 누적 합계를 계산하여 반환합니다.

3️⃣ 음수가 나타나면(**`value < 0`**), 누적을 중단하고(**`accumulating: false`**), 현재까지의 합계를 유지합니다.

4️⃣ 최종적으로 **`.total`** 을 사용하여 최종 합계만을 추출합니다.

🧑‍💻 코드의 결과는 "함수형, 조기 종료" 코드가 17을 출력한다는 것을 나타냅니다.
이는 **`numbers`** 배열내에서 음수 값이 나타나기 전까지의 숫자들의 합입니다.

🙋‍♂️ 설명한 부분에서 언급된 "컴파일러가 조기 종료가 가능하다는 것을 파악하기 위해 열심히 일해야 합니다. 실제로 현재의 Swift 컴파일러는 이를 아직 유추할 수 없으며 **`numbers`** 배열의 모든 요소를 반복합니다." 는 이 코드가 상당히 복잡하며, Swift 컴파일러가 이 로직을 분석하고 최적화하는 데 어려움을 겪을 수 있음을 나타냅니다.

🙋‍♂️ 특히, 컴파일러가 조기 종료 조건을 자동으로 감지하여 최적화하지 못하므로, 코드는 **`numbers`** 배열의 모든 요소를 반복적으로 처리하게 됩니다.
이는 컴파일러가 더 효율적인 실행 경로를 찾는 데 한계가 있음을 의미합니다.

### 🍗 문장 뜯어 먹기 냠냠 (6)

```swift
example("명령형, 조기 종료와 적시 변형성") {
	let total: Int = {
		// 동일한 오래된 명령형 코드
		var total = 0
		for value in numbers {
			guard value >= 0 else { break }
			total += value
		}
		return total
	}()
	print(total)
}
// 출시
// ## 명령형, 조기 종료와 적시 변형성
// 17
// ---
```

>이 코드는 명령형 코드를 클로저로 감싸고 바깥쪽 불변 `total`에 할당하기 위해 호출합니다.
이 방법으로 Swift는 "필요할 때만 변형"을 제공합니다.
이것은 자연스러운 해결책일 때 지역 변형(local mutation)을 사용하여 알고리즘을 표현할 수 있게 해줍니다.

🙋‍♂️ 위 제시된 Swift 예시 코드와 설명은 명령형 프로그래밍 스타일을 사용하여 특정 조건 하에 숫자 시퀀스의 합을 계산하는 방법을 보여줍니다.

🙋‍♂️ 구체적으로, 이 코드는 음수 값이 나타날 때까지 시퀀스의 숫자들을 누적하여 합산하는 과정을 구현합니다.

🧑‍💻 **코드 분석**

1️⃣ 코드는 클로저 안에서 시작합니다. 클로저는 즉시 실행되는 함수 블록으로, 여기서는 **`total`** 변수의 값을 계산하는 데 사용됩니다.

2️⃣ **`var total = 0`** 은 누적 합계를 저장할 변경 가능한(mutable) 변수를 초기화합니다.

3️⃣ **`for`** 루프를 사용하여 **`numbers`** 배열의 각 값을 반복적으로 확인합니다.

4️⃣ **`guard`** 문을 사용하여 각 값이 음수인지 확인합니다. 음수가 나타나면(**`value < 0`**), **`break`** 문을 통해 루프를 즉시 종료합니다.

5️⃣ 음수가 아닌 경우, 해당 값을 **`total`** 에 더합니다.

6️⃣ 루프가 종료되면, 클로저는 누적된 **`total`** 값을 반환합니다.

7️⃣ 이 반환된 값은 외부의 불변(immutable)변수 **`let total: Int`** 에 할당됩니다.

🙋‍♂️ 코드에 대한 설명에서 "명령형 코드를 클로저로 감싸고 바깥쪽 불변 **`total`** 에 할당하기 위해 호출합니다."는 이 방법이 Swift에서 제공하는 "필요할 때만 변형(mutation when you need it)"의 예라는 것을 나타냅니다.

🙋‍♂️ 이는 코드의 안정성과 예측 가능성을 높이는 방식입니다. 클로저 내부에서는 변수가 변경될 수 있지만, 클로저 외부에서는 결과값이 불변 변수로 처리되어, 코드의 안전성과 명확성을 제공합니다.
