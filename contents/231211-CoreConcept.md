# The Swift compiler 🤿

## 1️⃣ Overview.

Swift 도구 체인의 핵심은 Swift 컴파일러입니다.
이것은 소스 코드를 실행 파일로 연결할 수 있는 오브젝트 코드로 변환하는 역할을 담당합니다.
Swift 컴파일러는 LLVM 컴파일러 인프라 위에서 작동하며, 데이터 흐름은 아래 그림과 같습니다.

<img src = "https://github.com/devKobe24/images/blob/main/SWDD-Toolchain-1.png?raw=true"></br>

Swift와 같은 고수준 언어를 취하여 실제 하드웨어에서 효율적으로 실행될 수 있는 기계어로 변환하는 과정을 'lowering'이라고 합니다.
위에 보여진 둥근 사각형들은 사각형으로 표현된 각 단계의 입력이나 출력 데이터입니다.
각 단계를 고수준에서 이해하는 것이 중요합니다.

1️⃣ **Parse**

Swift 소스 코드는 먼저 토큰으로 파싱되어 추상 구문 트리(AST)로 구성됩니다.
이것을 각 표현식이 노드인 트리로 생각할 수 있습니다.
노드들은 소스 위치 정보도 가지고 있어서, 오류가 감지되면 문제가 발생한 정확한 위치를 알려줄 수 있습니다.

2️⃣ **Semantic Analysis(Sema)**

이 단계에서 컴파일러는 AST를 사용하여 프로그램의 의미를 분석합니다.
여기서 타입 체킹(type checking)이 이루어집니다.
타입 체크가 완료된 AST는 SILGen 단계로 전달됩니다.

3️⃣ **SILGen**

이 단계는 Clang과 같은 이전 컴파일러 파이프라인과 다르며, 이러한 단계가 없었습니다.
AST는 Swift 중간 언어(Swift Intermediate Language, SIL)로 변환됩니다.
SIL은 기본적인 계산 블록을 포함하며, Swift 타입, 참조 카운팅 및 디스패치 규칙을 이해합니다.
SIL에는 두 가지 형태가 있습니다.

- 원시(raw) SIL과 정규(canonical) SIL

정규 SIL은 원시 SIL이 최소한의 최적화 패스를 거친 결과물입니다.(모든 최적화가 꺼져 있을 때도).
SIL은 또한 소스 위치 정보를 포함하고 있어 의미 있는 오류를 생성할 수 있습니다.

4️⃣ **IRGen**

IRGen은 SIL을 LLVM의 중간 표현으로 변환하는 도구입니다.
이 시점에서, 명령어들은 더 이상 Swift 특정적이지 않습니다.(모든 LLVM 기반은 이 표현을 사용합니다.)
IR은 여전히 상당히 추상적입니다.
SIL 처럼, IR은 정적 단일 할당(SSA) 형식을 취합니다.
이는 기계들이 무제한의 레지스터를 가지고 있는 것처럼 모델링하며, 최적화를 찾기 쉽게 합니다.
Swift 타입에 대해선 아무것도 알지 못합니다.

5️⃣ **LLVM**

이 마지막 단계에서는 중간 표현(IR)을 최적화하고 특정 플랫폼을 위한 기계 명령어로 변환합니다.
백엔드(기계 명령어를 출력하는 것)에는 ARM, x86, Wasm등이 포함됩니다.

---

위  다이어그램은 Swift 컴파일러가 오브젝트 코드를 생성하는 과정을 보여 줍니다.
소스 코드 포매터, 리팩토링 도구, 문서 생성기 및 문법 강조 표시기와 같은 다른 도구들은 AST와 같은 중간 결과를 활용하여, 최종 결과물을 더욱 견고하고 일관되게 만들 수 있습니다.

> 📝 **Note**
> 
> 애플이 Xcode의 컴파일러 기술로 LLVM과 Clang을 채택하기 전에는,
> 문법 강조 표시, 문서 생성, 디버깅 및 컴파일링 모두 다른 파서를 사용했습니다.
> 대부분의 경우 이 방식은 잘 작동했습니다.
> 하지만, 이들이 동기화에서 벗어났을 때 이상한 상황이 발생하기도 했습니다.

### 🍗 문장 뜯어 먹기 냠냠(1)

> Swift와 같은 고수준 언어를 취하여 실제 하드웨어에서 효율적으로 실행될 수 있는 기계어로 변환하는 과정을 'lowering'이라고 합니다.
위에 보여진 둥근 사각형들은 사각형으로 표현된 각 단계의 입력이나 출력 데이터입니다.
각 단계를 고수준에서 이해하는 것이 중요합니다.

🙋‍♂️ 위 문장은 프로그래밍 언어의 컴파일 과정, 특히 'lowering' 이라는 단계에 대해 설명하고 있습니다. 이 문장에 대하여 분석해봅시다잇!!

1️⃣ **Swift와 같은 고수준 언어.**
고수준 업어는 사람이 이해하기 쉽고, 추상화 수준이 높은 프로그래밍 언어를 의미합니다.
Swift는 이러한 고수준 언어의 한 예입니다.

2️⃣ **실제 하드웨어에서 효율적으로 실행될 수 있는 기계어로 변환.**
프로그래밍 언어로 작성된 코드는 컴퓨터가 이해하고 실행할 수 있는 형태인 기계어로 변환되어야 합니다.
이 변환 과정을 'lowering'이라고 합니다.

3️⃣ **'Lowering'이라는 과정.**
'Lowering'은 고수준 언어를 하드웨어가 이해할 수 있는 낮은 수준의 언어,
즉 기계어로 변환하는 과정을 말합니다.
이는 프로그래밍 언어의 추상화를 구체적인 실행 명령으로 변환하는 중요한 단계입니다.

4️⃣ **둥근 사각형들은 각 단계의 입력이나 출력 데이터.**
이 부분은 컴파일 과정의 다양한 단계에서 사용되는 데이터를 나타냅니다.
둥근 사각형들은 각 단계에서 생성되거나 사용되는 데이터를 상징합니다.

5️⃣ **각 단계를 고수준에서 이해하는 것의 중요성.**
컴파일 과정의 각 단계를 이해하는 것은 프로그래밍 언어의 동작 방식과 컴퓨터가 코드를 어떻게 처리하는지를 이해하는 데 중요합니다.
이는 프로그래밍 언어의 이론과 실제 구현을 더 잘 이해하는 데 도움이 됩니다.

🙋‍♂️ 요약하면, 이 문장은 Swift와 같은 고수준 프로그래밍 언어가 실제 컴퓨터에서 실행되기 위해 기계어로 변환되는 과정인 'lowering'과 그 과정의 각 단계를 이해하는 것의 중요성을 설명하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(2)

> Swift 소스 코드는 먼저 토큰으로 파싱되어 추상 구문 트리(AST)로 구성됩니다.
이것을 각 표현식이 노드인 트리로 생각할 수 있습니다.
노드들은 소스 위치 정보도 가지고 있어서, 오류가 감지되면 문제가 발생한 정확한 위치를 알려줄 수 있습니다.

🙋‍♂️ 제시된 문장은 Swift 프로그래밍 언어의 컴파일 과정 중 파싱 단계에 대해 설명하고 있습니다. 이 문장을 분석해 봅시다 !!

1️⃣ **Swift 소스 코드 파싱.**
Swift 소스 코드는 컴파일 과정의 첫 단계에서 토큰으로 파싱됩니다.
파싱(parsing)은 소스 코드를 의미있는 단위(토큰)로 분해하는 과정을 말합니다.

2️⃣ **추상 구문 트리(AST)로 구성.**
파싱된 토큰들은 추상 구문 트리(Abstract Syntax Tree, AST)라는 구조로 재구성됩니다.
AST는 프로그램의 구문을 트리 구조로 나타낸 것으로, 프로그램의 구조와 의미를 표현합니다.

3️⃣ **표현식이 노드인 트리.**
이 트리에서 각 표현식(expressing)은 트리의 노드(node)로 표현됩니다.
즉, 프로그램의 각 구성 요소(예: 변수, 연산자, 함수 호출 등)가 트리의 한 노드가 됩니다.

4️⃣ **노드들은 소스 위치 정보를 가짐.**
AST의 각 노드는 해당 노드가 소스 코드의 어느 위치에 해당하는지를 나타내는 위치 정보를 포함합니다.

5️⃣ **오류 감지와 정확한 위치 제공.**
만약 컴파일 과정에서 오류가 감지되면, 해당 노드는 문제가 발생한 정확한 위치를 알려줄 수 있습니다.
이는 디버깅과 오류 수정을 훨씬 쉽게 만듭니다.

🙋‍♂️ 요약하면, 이 문장은 Swift 소스 코드가 어떻게 토큰으로 분해되고, 이 토큰들이 어떻게 AST로 재구성되며, 이 과정이 어떻게 오류 탐지와 수정에 도움이 되는지를 설명하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(3)

> 의미 분석 (Sema): 이 단계에서 컴파일러는 AST를 사용하여 프로그램의 의미를 분석합니다. 여기서 타입 체킹이 이루어집니다. 타입 체크가 완료된 AST는 SILGen 단계로 전달됩니다.

🙋‍♂️ 위 문장은 프로그래밍 언어의 컨파일 과정의 "의미 분석(Sema)" 단계에 대하여 설명하고 있습니다.

1️⃣ **의미 분석(Sema) 단계.**
이 단계에서는 컴파일러가 프로그램의 의미를 분석합니다.
이는 컴파일 과정 중 중요한 부분으로, 프로그램의 구문이 아닌 의미와 논리를 검토하는 단계입니다.

2️⃣ **AST 사용.**
컴파일러는 이 단계에서 추상 구문 트리(Abstract Syntax Tree, AST)를 사용합니다.
AST는 이전 단계에서 생성된 프로그램의 구조적 표현으로, 프로그램의 각 구성 요소와 그 관계를 나타냅니다.

3️⃣ **타입 체킹**
의미 분석 단계에서는 주로 타입 체킹(type checking)이 이루어집니다.
이는 프로그램 내의 각 변수, 표현식, 함수 등이 올바른 데이터 타입을 사용하고 있는지 확인하는 과정입니다.
타입 체킹을 통해 타입 관련 오류를 미리 감지하고 해결할 수 있습니다.

4️⃣ **타입 체크 완료된 AST의 SILGen 단계로의 전달.**
타입 체킹이 완료된 후, 이 AST는 컴파일 과정의 다음 단계인 SILGen(Swift Intermediate Language Generation)으로 전달됩니다.
SILGen 단계에서는 중간 코드가 생성되며, 이는 컴파일러가 최종 기계어 코드를 생성하기 전의 중간 단계입니다.

🙋‍♂️ 요약하면, 이 문장은 프로그래밍 언어 컴파일 과정에서 의미 분석 단계가 어떻게 이루어지고, 이 단계가 전체 컴파일 프로세스에서 어떤 역할을 하는지 설명하고 있습니다.
이 단계는 프로그램이 의미적으로 올바르고 타입 오류가 없는지 확인하는 데 중요합니다.

### 🍗 문장 뜯어 먹기 냠냠(4)

> SILGen 단계는 Clang과 같은 이전 컴파일러 파이프라인과 다르며, 이러한 단계가 없었습니다.

🙋‍♂️ 이 문장은 프로그래밍 언어의 컴파일 과정에서 특정 단계인 SILGen에 대해 설명하고 있으며, 그것이 Clang과 같은 이전 컴파일러 파이프라인과 어떻게 다른지를 지적하고 있습니다. 구체적으로 분석해봅시다!

1️⃣ **SILGen 단계.**
이는 Swift 컴파일러의 특정 단계를 나타냅니다.
SILGen 단계에서는 추상 구문 트리(AST)가 Swift 중간 언어(Swift Intermediate Language, SIL)로 변환됩니다.

2️⃣ **Clang과 같은 이전 컴파일러 파이프라인과의 차이.**
이 부분은 SILGen이 Clang과 같은 이전 컴파일러들에서는 사용되지 않던 새로운 단계라는 점을 강조합니다.
즉, Swift 컴파일러는 SILGen이라는 독특한 단계를 포함하고 있으며, 이는 이전의 컴파일러 설계와는 다른 접근 방식을 나타냅니다.

🙋‍♂️ 이 문장의 핵심!
Swift 컴파일러가 기존의 다른 컴파일러 파이프라인과는 다른, 새로운 방식을 도입했다는 것을 강조하는 데 있습니다.
SILGen 단계는 Swift의 컴파일 과정에서 중요한 역할을 하며, 이는 Swift가 다른 언어들과 구별되는 특징 중 하나입니다.

### 🍗 문장 뜯어 먹기 냠냠(5)

> AST는 Swift 중간 언어(Swift Intermediate Language, SIL)로 변환됩니다.

🙋‍♂️ 제시된 문장은 프로그래밍 언어, 특히 Swift의 컴파일 과정에서 발생하는 특정 단계를 설명하고 있습니다.
이 문장의 의미를 분석해 봅시다!!

1️⃣ **AST**
AST는 'Abstract Syntax Tree'의 약자로, 프로그램의 소스 코드를 구문적 구조로 나타낸 것입니다.
AST는 소스 코드의 구조와 의미를 트리 형태로 표현하여, 컴파일러가 코드를 더 쉽게 분석하고 처리할 수 있도록 합니다.

2️⃣ **Swift 중간 언어(Swift Intermediate Language, SIL)**
SIL은 Swift 컴파일러에서 사용되는 중간 표현 언어입니다.
이 언어는 Swift 소스 코드를 기계어로 변환하기 전의 중간 단계로, 컴파일러 최적화와 분석을 위해 사용됩니다.

3️⃣ **변환 과정**
AST가 SIL로 변환된다는 것은, 컴파일 과정에서 소스 코드의 구조적 표현이 중간 언어의 형태로 다시 표현되어,
추가적인 최적화 및 분석이 수행될 준비가 된다는 것을 의미합니다.

🙋‍♂️ 이 문장의 핵심은 Swift 컴파일러가 소스 코드의 구문적 구조를 중간 단계의 언어로 변환하여, 이를 통해 더 효율적인 코드 분석과 최적화를 수행할 수 있다는 점을 강조하는 데 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(6)

> SIL은 기본적인 계산 블록을 포함하며, Swift 타입, 참조 카운팅 및 디스패치 규칙을 이해합니다.

🙋‍♂️ 제시된 문장은 Swift 프로그래밍 언어의 컴파일 과정 중에 사용되는 중간 언어인 Swift Itermediate Language(SIL)의 특성에 대해 설명하고 있습니다.

이 문장의 내포된 의미를 분석해 봅시다!!

1️⃣ **기본적인 계산 블록 포함.**
SIL에는 프로그램의 기본적인 계산 단위나 논리적인 구성 요소들이 포함되어 있습니다.
이는 프로그램의 복잡한 로직이나 연산을 더 작고 관리하기 쉬운 단위로 나누어 표현된 것을 의미합니다.

2️⃣ **Swift 타입 이해.**
SIL은 Swift 언어의 타입 시스템을 이해하고, 이에 따라 타입 관련 연산이나 검증을 처리합니다.
이는 타입 안전성을 보장하고, 타입 관련 최적화를 가능하게 합니다.

3️⃣ **참조 카운팅 이해.**
SIL은 Swift의 메모리 관리 방식인 참조 카운팅을 처리하고 이해합니다.
이는 객체의 생명주기와 메모리 관리를 효율적으로 다룰 수 있게 해 줍니다.

4️⃣ **디스패치 규칙 이해.**
디스패치(함수 호출의 결정과 실행 방법)규칙 또한 SIL에 의해 처리됩니다.
이는 메소드 호출이 어떻게 해석되고 실행될지를 결정하는 데 중요한 역할을 합니다.

🙋‍♂️ 요약하면!
이 문장은 SIL이 Swift 프로그램의 기본 연산, 타입 시스템, 메모리 관리, 함수 호출 방식 등을 이해하고 처리할 수 있는 능력을 가지고 있음을 나타냅니다.
이러한 특성은 Swift 컴파일러가 효율적으로 최적화하고 실행 가능한 코드를 생성하는 데 핵심적인 역할을 합니다.

### 🍗 문장 뜯어 먹기 냠냠(7)

> IRGen은 SIL을 LLVM의 중간 표현으로 변환하는 도구입니다.
이 시점에서, 명령어들은 더 이상 Swift 특정적이지 않습니다.(모든 LLVM 기반은 이 표현을 사용합니다.)

🙋‍♂️ 제시된 문장은 프로그래밍 언어 변환 및 컴파일 과정에서의 특정 단계에 대해 설명하고 있습니다. 우리 한번 쪼개서 분석해볼까용!!

1️⃣ **IRGen 도구의 역할.**
IRGen은 "Swift Intermediate Language(SIL)"을 "Low Level Virtual Machien"(LLVM) 의 중간 표현(IR)으로 변환합니다.
이는 Swift 언어로 작성된 코드를 더 낮은 수준의, 하드웨어에 더 가까운 형식으로 변환하는 과정을 의미합니다.

2️⃣ **LLVM의 중간 표현(IR)의 특성.**
이 변환 후의 단계에서, 코드는 더 이상 Swift 언어의 특정 구조나 문법에 종속되지 않습니다.
LLVM의 IR은 다양한 프로그래밍 언어를 지원하기 위한 보다 일반적이고 추상적인 형태를 취합니다.
이는 LLVM이 다양한 언어의 백엔드 컴파일러로서 가능할 수 있게하는 핵심 요소입니다.

3️⃣ **다양한 언어와의 호환성.**
괄호 안의 문구는 LLVM의 중간 표현이 Swift에만 국한되지 않고,
모든 LLVM 기반 언어에서 사용된다는 점을 강조합니다.
이는 LLVM이 매우 범용적인 컴파일러 인프라로서 작동한다는 것을 시사합니다.

4️⃣ **Swift 특정적인 요소의 제거.**
이 변환 과정을 통해, Swift 언어의 구체적인 요소들은 제거되며,
결과적으로 얻어지는 중간 표현은 더 넓은 범위의 최적화 및 하드웨어 타겟팅에 적합한 형태로 남게 됩니다.

🙋‍♂️ 요약!!
이 문장은 컴파일 과정에서 Swift 코드가 LLVM의 보다 일반적인 중간 표현으로 변환되는 과정을 설명하며, 이를 통해 다양한 언어와 플랫폼에 걸쳐 활용될 수 있는 유연성과 범용성을 강조하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(8)

> SIL 처럼, IR은 정적 단일 할당(SSA) 형식을 취합니다.

🙋‍♂️ 위 문장은 프로그래밍 언어의 중간 표현에 관한 중요한 개념인 '정적 단일 할당(Static Single Assignment, SSA)' 형식에 대해 언급하고 있습니다.

여기서 'SIL'은 Swift Intermediate Language의 약자이며, 'IR'은 Intermediate Representation(중간 표현을 의미합니다.)

이제 문장을 분석해봅시다!!.

1️⃣ **정적 단일 할당(SSA) 형식.**
SSA는 컴파일러 설계에서 사용되는 방법론으로, 각 변수가 단 한 번만 할당되는 형태로 프로그램을 표현합니다.
이 방식에서, 각 변수의 할당은 고유한 식별자를 가지며, 이는 프로그램의 각 지점에서 변수의 값이 명확히 정의되어 있음을 의미합니다.

2️⃣ **SIL과 IR에서의 SSA 적용.**
SIL과 LLVM의 IR 모두 이 SSA 형식을 채택합니다.
이는 두 중간 표현에서 프로그램이 SSA 형식으로 변환되어, 각 변수가 한 번만 할당되고 그 값이 프로그램 전반에 걸쳐 일관되게 유지됨을 의미합니다.

3️⃣ **최적화와 분석의 용이성.**
SSA 형식의 컴파일러 최적화와 프로그램 분석을 용이하게 합니다.
각 변수가 한 번만 할당된다는 점은 데이터 흐름과 종속성 분석을 간소화하며, 최적화 과정에서 더 명확하고 효율적인 결정을 내리는 데 도움이 됩니다.

4️⃣ **SIL과 IR의 유사성.**
SIL(특정한 언어인 Swift의 중간 표현)과 LLVM의 IR(다양한 언어를 위한 보다 일반적인 중간 표현) 모두 SSA를 사용한다는 점은, 이러한 중간 표현들이 어떻게 효율적인 컴파일러 설계를 지원하는지를 보여줍니다.
SSA 형식은 이러한 시스템들이 프로그램 구조를 효과적으로 분석하고 변환할 수 있게 만듭니다.

🙋‍♂️ 요약!
이 문장은 SIL과 IR이 SSA 형식을 사용함으로써 컴파일러 최적화와 프로그램 분석에 있어서의 이점을 강조하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(9)

> IRGen은 기계들이 무제한의 레지스터를 가지고 있는 것처럼 모델링하며, 최적화를 찾기 쉽게 합니다.
Swift 타입에 대해선 아무것도 알지 못합니다.

🙋‍♂️ 위 문장은 Swift 프로그래밍 언어의 컴파일 과정 중 하나인 IRGen(Intermediate Representation Generation)의 특성을 설명하고 있습니다.
각 부분의 의미를 구체적으로 살펴 볼까요?!

1️⃣ **IRGen은 기계들이 무제한의 레지스터를 가지고 있는 것처럼 모델링하며, 최적화를 찾기 쉽게 합니다.**
IRGen이 코드를 중간 표현으로 변환할 때, 
실제 하드웨어의 물리적인 제한 사항인 레지스터의 수를 고려하지 않고 무제한으로 가지고 있는 것처럼 가정한다는 것을 의미합니다.
이런 가정을 통해 컴파일러는 더 효율적인 최적화 결정을 내릴 수 있는 여지를 갖게 됩니다.
실제 물리적 레지스터로의 할당은 이후의 백엔드 처리 과정(레지스터 할당)에서 수행됩니다.

2️⃣ **Swift 타입에 대해선 아무것도 알지 못합니다.**
IRGen이 생성하는 중간 표현이 Swift의 고수준 타입 시스템과 독립적으로 작동한다는 것을 나타냅니다.
즉, 중간 표현은 타입 정보를 추상화하고, 더 범용적이고 저수준의 형태로 코드를 표현합니다.
이로 인해, 중간 표현은 Swift의 복잡한 타입 정보를 직접적으로 반영하지 않으며,
대신 타입을 더 단순화된 형태로 변환하여 처리합니다.

🙋‍♂️ **결론!!**
이 문장은 IRGen이 최적화 과정에서 어떻게 물리적 제약을 초월하여 추상화를 실시하고,
Swift의 고수준 타입 시스템과는 독립적으로 작동하는 중간 코드를 생성하는지를 설명하고 있습니다.
이는 컴파일러 설계의 일반적인 접근 방식을 반영하는 것으로,
이를 통해 컴파일러는 더 넓은 최적화 공간을 활용할 수 있게 됩니다.

### 🍗 문장 뜯어 먹기 냠냠(10)

> 이 마지막 단계에서는 중간 표현(IR)을 최적화하고 특정 플랫폼을 위한 기계 명령어로 변환합니다.
백엔드(기계 명령어를 출력하는 것)에는 ARM, x86, Wasm등이 포함됩니다.

🙋‍♂️ 이 문장은 컴파일러의 작동 원리와 백앤드 단계의 역할에 대해 설명하고 있습니다.
구체적으로 문장을 살펴봅시다잇!!

1️⃣ **"이 마지막 단계에서는 중간 표현(IR)을 최적화하고 특정 플랫폼을 위한 기계 명령어로 변환합니다."**
LLVM 컴파일러의 최종 단계에서 수행하는 작업을 나타냅니다.
여기서 중간 표현(IR)은 추가적인 최적화를 거쳐서 최종적으로 특정 플랫폼(예: 특정 CPU 아키텍처)에서 실행 가능한 기계어 코드로 변환됩니다.

2️⃣ **"백앤드(기계 명령어를 출력하는 것)에는 ARM, x86, Wasm 등이 포함됩니다."**
백앤드는 다양한 하드웨어 아키텍처를 대상으로 기계어 코드를 생성하는 컴파일러의 구성 요소입니다.
각 백엔드는 특정 아키텍처(ARM, x86, WebAssembly(Wasm)등)에 맞게 최적화된 기계어 명령어를 출력합니다.

🙋‍♂️ 종합하면!!
이 문장은 LLVM 컴파일러 프로세스의 일부로서, 소스 코드가 중간 표현으로 변환된 후, 다양한 아키텍처에 맞는 최종 기계어 명령어로 변환되는 과정을 설명하고 있습니다.
이를 통해 개발자는 동일한 소스 코드로부터 다양한 플랫폼에 대응하는 실행 파일을 생성할 수 있음을 의미합니다.
