# Key points 🤿

`Section 1: Core Concepts` 에서는 Swift 언어를 구축하는 데 대한 몇 가지 동기와 Swift의 라이브러리 및 컴파일러가 어떻게 협력하여 강력한 추상화를 만들어내는지에 대해 다뤘습니다.

여기 몇 가지 주요 요약 사항이 있습니다.

- 스위프트는 명령형, 함수형, 객체 지향, 프로토콜 지향, 제네릭 패러다임을 포함한 여러 프로그래밍 스타일을 지원하는 다중 패러다임 언어입니다.
- 스위프트는 합리적인 기본값을 선택하여 정의되지 않은 동작을 발생시키기 어렵게 만드는 것을 목표로 합니다.
- 스위프트는 점진적인 공개의 개념을 받아들입니다. 더 고급 언어 기능에 대해서는 필요할 때만 배워야 합니다.
- 스위프트는 강력한 타입 시스템과 타입 추론을 특징으로 하는 범용 프로그래밍 언어입니다.
- 스위프트의 많은 부분은 표현력 있는 표준 라이브러리에 정의되어 있으며 컴파일러의 일부가 아닙니다.
- 스위프트의 컴파일러 단계는 파싱, 의미분석, SILGen, IRGen 및 LLVM 입니다.
- 소스 위치 정보는 AST와 SIL애 존재하여 더 나은 오류 보고가 가능하게 합니다.
- SIL은 SSA 형식으로 작성된 기본 블록의 명령어를 사용하는 저수준 설명입니다. 이는 스위프트 타입의 의미를 이해하므로 LLVM IR만으로는 불가능한 많은 최적화를 가능하게 합니다.
- SIL은 확실한 초기화, 메모리 할당 최적화 및 가상화 해제를 지원하는 데 도움이 됩니다.
- Any는 스위프트의 궁극적인 타입 삭제입니다만, 사용하기에 오류가 발생하기 쉽습니다. 제네릭은 일반적으로 더 나은 대안입니다.
- 함수 본문 내에서 인자의 평가를 지연시키기 위해 값을 반환하는 클로저를 매개변수로 전달합니다.
- `@autoclosure`는 표현식 인자의 실행을 지연시킴으로써 단락 동작을 구현하는 방법입니다.
- rethrow는 throws로 표시될 수도 있고 그렇지 않을 수도 있는 클로저로부터의 오류를 전파하는 방법입니다.
- `@inlinable`은 함수의 명령어가 호출 지점에 포함되어야 함을 컴파일러에게 암시합니다.
- 컴파일러는 소스 코드의 추상화 비용을 대부분 또는 전부 제거합니다. 다른 소스 코드가 동일한 의미를 가지면, 컴파일러는 동일한 기계 명령어를 생성할 가능성이 높습니다.
- 추상화는 자신의 가치를 지불해야 합니다. 새로운 언어 기능을 만들기 전에 심사숙고하세요.
