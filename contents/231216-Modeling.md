# Types & Mutation: Modeling with types 🤿

이차원 기하학은 수학적으로 잘 정의되어 있고 시각화하기 쉬워 타입 시스템을 탐구하기에 좋은 문제영역입니다.
아래 코드를 봐봅시다.

```swift
import Foundation

struct StructPoint {
	var x, y: Double
}

class ClassPoint {
	var x, y: Double
	init(x: Double, y: Double) { (self.x, self.y) = (x, y) }
}
```

이 두 타입 모두 x-y 평면에서의 점을 모델링합니다.<br>
하지만 이미 인식해야 할 다섯 가지 중요한 차이점이 있습니다.<br>

## Difference 1: Auto initialization

첫 번째이자 가장 분명한 차이점은 클래스 타입에 초기화자가 필요하다는 것입니다.<br>
초기화자를 선언하지 않으면, 컴파일러는 구조체에 대해 내부 멤버별 초기화자를 선언합니다.<br>
이 초기화자는 단순히 멤버 속성을 하나씩 할당합니다.<br>
`x`와 `y`가 초기화되어야 하기 때문에 클래스에 대한 초기화자를 정의해야 합니다.<br>

> 📝 Note.
> 
> 구조체에 대한 초기화자를 정의하면, 컴파일러는 멤버별 초기화자를 생성하지 않습니다.<br>
> 컴파일러가 생성한 초기화자와 사용자 정의 초기화자 둘 다 원한다면, 확장에서 초기화자를 정의하는 것이 일반적인 방법입니다.<br>

## Difference 2: Copty Semantics

두 번째로 크고 아마도 가장 중요한 차이점은 복사 의미론입니다.<br>
클래스는 참조 의미론을 가지고 있고, 구조체는 값 의미론을 가집니다.<br>
값 의미론은 두 인스턴스 A와 B가 주어졌을 때, A에 변경을 가함으로써 B의 값을 영향을 줄 수 없으며, 그 반대의 경우도 마찬가지라는 것을 말합니다.<br>
참조 의미론을 사용하면, 한 객체를 통해 다른 객체에 영향을 줄 수 있습니다.<br>

아래 코드를 봐봅시다.<br>

```swift
let structPointA = StructPoint(x: 0, y: 0)
var structPointB = structPointA
structPointB.x += 10
print(structPointA.x) // not affected, prints 0.0

let classPointA = ClassPoint(x: 0, y: 0)
let classPointB = classPointA
classPointB.x += 10
print(classPointA.x) // affected, prints 10.0
```

참조 의미론을 사용할 때, `classPointB`를 변경하면 `classPointA`도 영향을 받습니다.<br>
왜냐하면 두 변수 모두 같은 기본 메모리를 가리키기 때문입니다.<br>
이 현상은 `structPointA` 와 `structPointB` 가 값의 의미론을 가진 독립적인 복사본인 구조체에서는 발생하지 않습니다.<br>

## Difference 3: Scope of mutation

스위프트는 인스턴스 수준의 변형 모델을 지원합니다.<br>
이는 `var` 대신 `let` 키워드를 사용함으로써 인스턴스 변형을 제한할 수 있음을 의미합니다.<br>
이것이 위의 코드에서 `structPointB`를 `var`로 선언해야하는 이유입니다.<br>
그렇지 않으면 `x` 좌표에 `10`을 더할 수 없습니다.<br>
컴파일러는 오류로 이를 방지할 것입니다.<br>
`let`으로 `classPointB`를 도입하더라도 클래스 버전의 `x`좌표를 수정할 수 있는 것에 주목하세요.<br>
변형 제어는 기본 속성 데이터가 아닌 참조 자체에 적용됩니다.<br>

### Value semantics through immutability

위의 예에서 본 바와 같이 클래스는 참조 의미론을 가진 참조 타입입니다.<br>
클래스에 값 의미론을 부여할 수 있을까요?<br>
그 대답은 "예"이며, 가장 쉬운 방법은 불변성을 통한 것입니다.<br>
모든 속성을 `let`으로 선언하여 불변으로 만듭니다.<br>
어디서든 어떤 것도 수정할 수 없기 때문에, 이것은 값 의미론의 정의를 충족 시킵니다.<br>
함수형 언어는 종종 성능의 대가를 치르면서 엄격한 불변성을 사용하여 값 의미론을 달성합니다.<br>

> 📝 Note.
> 
> `Objective-C`는 타입 수준의 변형 모델을 사용합니다.<br>
> 예를 들어, `NSString`은 불변입니다.<br>
> 하지만 `NSString`에서 파생된 `NSMutableString`은 가변성을 추가합니다.<br>
> 그러나 `NSString`에 대한 포인터를 가지고 있다고 해도, 그것이 다른 클라이언트가 수정할 수 있는 `NSMutableString`을 가리키지 않는다고 100퍼센트 확신할 수는 없습니다.<br>
> 방어적 복사가 필요하게 되며, 이는 덜 효율적이고, 덜 안전하며, 더 오류가 발생하기 쉬운 프로그래밍 모델을 만듭니다.<br>

`StructPoint` 에서 `x`와 `y`속성을 `var`로 선언하는 것의 아름다움은 인스턴스를 `var`로 선언하면 가변적일 수 있고,<br>
`let`으로 선언하면 불변적일 수 있다는 것입니다.<br>
그래서 구조체 속성을 보통 `var`로 선언하고 싶어하는 이유는 사용 시점에서 각 인스턴스의 가변성을 제어할 수 있기 때문입니다.<br>

## Difference 4: Heap VS Stack

일반적인 경험으로, 클래스는 힙 메모리를 사용하지만 구조체와 열거형은 스택 메모리를 사용합니다.<br>
스택 할당은 힙 할당보다 몇 배 빠르기 때문에, 여기서 값 타입이 빠른 명성을 얻게 됩니다.<br>

각 실행 스레드는 자신만의 스택을 가지며, 스택은 맨 위의 요소를 수정함으로써만 변경됩니다.<br>
그 결과 스택에 할당하고 해제하는 것은 비싼 동시성 잠금이나 복잡한 할당 전략을 요구하지 않습니다.<br>
할당과 해제는 단일 클록 틱에서 단일 추가 또는 빼기 명령으로 수행될 수 있습니다.<br>

반면에 힙은 여러 스레드에 의해 공유되며 동시성 잠금으로 보호되어야 합니다.<br>
운영 체제는 다양한 크기의 메모리 블록을 할당하고 해제할 때 발생할 수 있는 힙 단편화를 방지해야 합니다.<br>
그 결과, 힙 할당이 고도로 최적화되었음에도 불구하고, 궁극적으로 비결정적이며 수천 또는 수백만 명령을 수행하는 데 필요할 수 있습니다.<br>

다음은 위의 코드가 메모리에 할당될 때 어떻게 보일지에 대한 다이어그램입니다.<br>

<img src = "https://github.com/devKobe24/images/blob/main/SWDD-4.png?raw=true"><br>

구조체는 스택에 배치되는 반면, 클래스는 스택과 힙 모두에 배치됩니다.<br>
힙 메모리의 참조 카운트는 참조 타입이 공유되기 때문에 객체의 수명을 추적합니다.<br>
참조 카운트가 0으로 떨어질 때만 `deinit`이 호출되고 메모리가 해제됩니다.<br>

> 📝 Note.
> 
> 클래스에는 힙, 구조체와 열거형에는 스택을 사용하는 것은 일반적인 경험일 뿐입니다.<br>
> 이전 장에서 본 것 처럼, 스위프트 컴파일러는 처음에 모든 것을 힙에 할당한 후 객체의 수명을 고려하여 스택에 할당할 수 있는지 결정합니다.<br>
> 예를 들어, 로컬 구조체를 닫는 탈출 클로저는 구조체의 수명을 그 범위를 넘어서 연장하기 위해 해당 객체를 힙에 두어야 할 수 있습니다.<br>
> 반면에 생성되어 어떤 작업을 수행한 후 범위를 벗어나는 클래스는 완전히 최적화되어 해당 작업을 완료하는 데 필요한 명령어만 포함될 수 있습니다.<br>

## Difference 5: Lifetime and identity.

값 타입, 예를 들어 구조체나 열거형은 일반적으로 스택에 존재하며 복사하는 데 비용이 적게 듭니다.<br>
값에는 수명이나 본질적인 정체성의 개념이 없습니다.<br>
참조에는 수명이 있으며, 그 때문에 참조에 대해 `deinit` 함수를 정의할 수 있습니다.<br>
또한, 특정 메모리 위치에 존재하기 때문에 자동으로 정체성을 가지게 됩니다.<br>
이를 돝애 그들을 식별할 수 있습니다.<br>

> 📝 Note.
> 
> 특정 속성을 통해 값 타입에 고유한 정체성을 부여할 수 있습니다.<br>
> `Identifiable` 프로토콜은 `Hashable`(그리고 `Equatable`) `id속성`을 추가함으로써 이를 수행합니다.<br>
> SwiftUI 프레임워크는 `@State`와 같은 속성 래퍼를 정의하는데, 이는 다른 것들 중에서도 간단한 값 타입에 생명주기를 부여합니다.<br>

## More differences

이 간단한 예시로는 클래스와 구조체 사이의 다른 차이점들을 설명하기 어렵습니다.<br>
가장 두드러진 차이점 중 하나는 상속입니다.<br>
클래스는 상속을 사용하여 런타임 다형성을 실현합니다.<br>
클래스는 메소드를 동적으로 디스패치하는 반면, 구조체는 프로토콜을 사용하지 않는 한 이러한 디스패치가 발생하지 않습니다.<br>
프로토콜의 일부가 아닌 구조체 메소드에 대해서는 디스패치가 정적으로 발생합니다.<br>

> 📝 Note.
> 
> 클래스에서 메소드를 `final`로 표시하면 가상화를 해제하고 실행 속도를 높일 수 있는 부작용이 있을 수 있습니다.<br>
> 컴파일러는 접근 제어와 전체 모듈 최적화에서 제공하는 힌트를 사용하여 메소드가 오바라이드될 수 없음을 증명하고 최적화할 수 있습니다.<br>

## Defining a Point

위에 언급된 차이점들을 고려할 때, `Point`를 가벼운 타입으로 표현하는 것이 좋은 선택일 가능성이 높습니다.<br>
아래의 코드를 봐봅시다.<br>

```swift
struct Point: Equatable {
	var x, y: Double
}

struct Size: Equatable {
	var width, height: Double
}

struct Rectangle: Equatable {
	var origin: Point
	var size: Size
}
```

이것이 `Point`, `Size` 및 `Rectangle`을 `Equatable` 준수와 함께 정의합니다.<br>
값 타입의 경우, 저장된 속성이 `Equatable` 타입이라면 컴파일러가 필요한 `==` 메소드를 자동으로 생성해 줍니다.<br>
참조 타입(즉, 클래스)은 `Equatable`에 대한 `==`와 `Hashable` 에 대한 `hash(into:)`를 직접 작성해야합니다.<br>

값의 의미론의 또 다른 중요한 특징은 그것들이 조합될 수 있다는 것입니다.<br>
`Rectangle`은 값 타입이고 `Point`와 `Size` 모두 값 의미론을 가지기 때문에 값 의미론을 갖습니다.<br>
또한 Swift 배열이 값 의미론을 가지므로 `Rectangle`의 배열도 값 의미론을 가집니다.<br>

> 📝 Note.
> 
> 코드 합성은 컴파일러의 타입 체킹 단계 동안 발생합니다.<br>
> 프로토콜을 채택할 때, 컴파일러는 타입이 프로토콜을 충족(증명)하는지 확인합니다.<br>
> 만약 충족하지 않는다면, 일반적으로 오류를 발생시킵니다.<br>
> `Equatable`의 특별한 경우에, 타입이 값 타입이고 모든 저장된 속성이 `Equatable`인 경우 `==`를 합성하려고 시도합니다.<br>
> `Hashable`, `Codable`, `CaseIterable`에 대해서도 유사한 과정이 일어납니다.<br>
> 다른 것들과 달리, `Codable`은 값 타입과 참조 타입 모두에 대한 코드를 합성합니다.<br>
